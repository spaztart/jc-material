{"version":3,"file":"updates.js","sourceRoot":"","sources":["../../src/common/updates.ts"],"names":[],"mappings":"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","sourcesContent":["import chalk from 'chalk'\nimport { logger } from './logging'\nimport { execSync } from 'child_process'\nimport { compareVersions } from 'compare-versions'\nimport { BaseCommand } from '../commands/connect'\nimport { Command } from 'commander'\nimport { request } from './fetch'\n\nlet updatedVersionAvailable: string | false | undefined = undefined\nlet message: string | undefined = undefined\n\n// The type of the arguments passed to a command handler:\n// any arguments, then the command arguments, then the Command object\ntype CommandArgs<T extends BaseCommand> = [...any[], T, Command]\n\n// Wrap action handlers to check for updates or a message, and output a message\n// after the action if any are available\nexport function withUpdateCheck<T extends BaseCommand>(\n  // The second to last argument is always the command args, but I couldn't work\n  // out how to model this with Typescript here\n  fn: (...args: any[]) => void | Promise<void>,\n) {\n  return (...args: CommandArgs<T>) => {\n    // Get the args passed at the command line (the second to last argument)\n    const commandArgs = args[args.length - 2]\n    // Anything before that is a regular arg\n    const restArgs = args.slice(0, -2)\n\n    if (commandArgs.skipUpdateCheck) {\n      return fn(...restArgs, commandArgs)\n    }\n\n    startUpdateCheck()\n\n    const result = fn(...restArgs, commandArgs)\n    if (result instanceof Promise) {\n      result.finally(waitAndCheckForUpdates)\n    } else {\n      waitAndCheckForUpdates()\n    }\n  }\n}\n\n// Start checking for updates in the background. We don't wait for this before\n// running the action, as we will show the result at the end\nfunction startUpdateCheck() {\n  request\n    .get<{ tag_name: string }>('https://api.github.com/repos/figma/code-connect/releases/latest')\n    .then((response) => {\n      const latestVersion = response.data.tag_name.replace(/^v/, '')\n      const currentVersion = require('../../package.json').version\n\n      if (compareVersions(latestVersion, currentVersion) === 1) {\n        updatedVersionAvailable = latestVersion\n      } else {\n        updatedVersionAvailable = false\n      }\n    })\n    .catch(() => {\n      // Silently fail if we can't check for updates\n      updatedVersionAvailable = false\n    })\n}\n\n// Wait for up to 1 second for the result of update checking to be available,\n// and output a message if there is an update or a message. If there is no\n// result after the timeout, the app will exit.\nasync function waitAndCheckForUpdates() {\n  for (let i = 0; i < 10; i++) {\n    if (updatedVersionAvailable !== undefined) {\n      break\n    }\n    await new Promise((resolve) => setTimeout(resolve, 100))\n  }\n\n  maybeShowUpdateMessage()\n}\n\n// Exit the process, first checking if there is an update or message available.\n// Unlike waitAndCheckForUpdates, this will not wait for the update check to\n// complete, so if the request has not completed yet, nothing will be shown.\n// This is to avoid confusion about when the process _actually_ exits.\nexport function exitWithUpdateCheck(errorCode = 1): never {\n  maybeShowUpdateMessage()\n  process.exit(errorCode)\n}\n\nfunction getUpdateCommand() {\n  return 'npm update -g @figma/code-connect'\n}\n\nfunction maybeShowUpdateMessage() {\n  if (updatedVersionAvailable) {\n    logger.warn(`\\nA new version of the Figma CLI is available. v${require('../../package.json').version} is currently installed, and the latest version available is v${updatedVersionAvailable}.\n\nTo update, run ${chalk.whiteBright('npm install @figma/code-connect@latest')} for React or HTML, or ${chalk.whiteBright('npm install -g @figma/code-connect@latest')} for other targets (or if you have Code Connect installed globally).`)\n  }\n\n  if (message) {\n    logger.warn(`\\n${message}`)\n  }\n}\n\nexport function updateCli() {\n  execSync(getUpdateCommand(), { stdio: 'inherit' })\n}\n"]}