"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.formatFileError = formatFileError;
exports.formatNetworkError = formatNetworkError;
exports.formatValidationError = formatValidationError;
exports.extractErrorMessage = extractErrorMessage;
/**
 * Formats a file operation error
 */
function formatFileError(opts) {
    const { operation, filePath, error: err, suggestion } = opts;
    let output = `âŒ Failed to ${operation} file: ${filePath}\nError: ${err.message}`;
    const defaultSuggestions = {
        read: 'Ensure the file exists and is readable.',
        access: 'Ensure the file exists and is readable.',
        write: 'Ensure the directory exists and is writable.',
        parse: 'Check the file syntax.',
    };
    const suggestionText = suggestion || defaultSuggestions[operation];
    if (suggestionText) {
        output += `\nðŸ’¡ ${suggestionText}`;
    }
    return output;
}
/**
 * Formats a network/API error
 */
function formatNetworkError(opts) {
    const { operation, url, statusCode, error: err, suggestion } = opts;
    let output = `âŒ Network error: ${operation} failed`;
    if (statusCode) {
        output += ` (HTTP ${statusCode})`;
    }
    if (url) {
        output += `\nURL: ${url}`;
    }
    output += `\nError: ${err.message}`;
    const defaultSuggestions = {
        '401': 'Check your Figma access token is valid.',
        '403': 'Check your Figma access token has the necessary permissions.',
        '404': 'Resource not found. Verify the URL or node ID is correct.',
        '5xx': 'Figma server error. Try again later.',
        default: 'Check your internet connection.',
    };
    let suggestionText = suggestion;
    if (!suggestionText && statusCode) {
        if (statusCode === 401 || statusCode === 403) {
            suggestionText = defaultSuggestions['401'];
        }
        else if (statusCode === 404) {
            suggestionText = defaultSuggestions['404'];
        }
        else if (statusCode >= 500) {
            suggestionText = defaultSuggestions['5xx'];
        }
        else {
            suggestionText = defaultSuggestions.default;
        }
    }
    else if (!suggestionText) {
        suggestionText = defaultSuggestions.default;
    }
    output += `\nðŸ’¡ ${suggestionText}`;
    return output;
}
/**
 * Formats a validation error
 */
function formatValidationError(opts) {
    const { item, errors, suggestion } = opts;
    let output = `âš ï¸  Validation failed for ${item}:`;
    errors.forEach((err) => {
        output += `\n  - ${err}`;
    });
    if (suggestion) {
        output += `\nðŸ’¡ ${suggestion}`;
    }
    return output;
}
/**
 * Extracts the most relevant error message from a stack of errors
 * @param error - The error to extract a message from
 * @param isVerbose - Whether verbose mode is already enabled (to avoid suggesting --verbose when it's already on)
 */
function extractErrorMessage(error, isVerbose = false) {
    if (error instanceof Error) {
        // Check if it's a Zod error by checking for issues property
        if ('issues' in error && Array.isArray(error.issues)) {
            const issues = error.issues;
            const errorMessages = issues.map((issue) => {
                // Format path with bracket notation for array indices
                const path = issue.path
                    .map((segment, index) => {
                    if (typeof segment === 'number') {
                        return `[${segment}]`;
                    }
                    return index === 0 ? segment : `.${segment}`;
                })
                    .join('');
                return `${issue.message} at "${path}"`;
            });
            const baseMessage = `Validation error: ${errorMessages.join('; ')}.`;
            // Only suggest --verbose if it's not already enabled
            return isVerbose
                ? baseMessage
                : `${baseMessage} Try re-running the command with --verbose for more information.`;
        }
        return error.message;
    }
    if (typeof error === 'string') {
        return error;
    }
    return String(error);
}
//# sourceMappingURL=error_formatting.js.map