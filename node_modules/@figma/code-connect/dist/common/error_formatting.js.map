{"version":3,"file":"error_formatting.js","sourceRoot":"","sources":["../../src/common/error_formatting.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * Formats a file operation error\n */\nexport function formatFileError(opts: {\n  operation: 'read' | 'write' | 'parse' | 'access'\n  filePath: string\n  error: Error\n  suggestion?: string\n}): string {\n  const { operation, filePath, error: err, suggestion } = opts\n\n  let output = `‚ùå Failed to ${operation} file: ${filePath}\\nError: ${err.message}`\n\n  const defaultSuggestions: Record<string, string> = {\n    read: 'Ensure the file exists and is readable.',\n    access: 'Ensure the file exists and is readable.',\n    write: 'Ensure the directory exists and is writable.',\n    parse: 'Check the file syntax.',\n  }\n\n  const suggestionText = suggestion || defaultSuggestions[operation]\n  if (suggestionText) {\n    output += `\\nüí° ${suggestionText}`\n  }\n\n  return output\n}\n\n/**\n * Formats a network/API error\n */\nexport function formatNetworkError(opts: {\n  operation: string\n  url?: string\n  statusCode?: number\n  error: Error\n  suggestion?: string\n}): string {\n  const { operation, url, statusCode, error: err, suggestion } = opts\n\n  let output = `‚ùå Network error: ${operation} failed`\n\n  if (statusCode) {\n    output += ` (HTTP ${statusCode})`\n  }\n  if (url) {\n    output += `\\nURL: ${url}`\n  }\n  output += `\\nError: ${err.message}`\n\n  const defaultSuggestions: Record<string, string> = {\n    '401': 'Check your Figma access token is valid.',\n    '403': 'Check your Figma access token has the necessary permissions.',\n    '404': 'Resource not found. Verify the URL or node ID is correct.',\n    '5xx': 'Figma server error. Try again later.',\n    default: 'Check your internet connection.',\n  }\n\n  let suggestionText = suggestion\n  if (!suggestionText && statusCode) {\n    if (statusCode === 401 || statusCode === 403) {\n      suggestionText = defaultSuggestions['401']\n    } else if (statusCode === 404) {\n      suggestionText = defaultSuggestions['404']\n    } else if (statusCode >= 500) {\n      suggestionText = defaultSuggestions['5xx']\n    } else {\n      suggestionText = defaultSuggestions.default\n    }\n  } else if (!suggestionText) {\n    suggestionText = defaultSuggestions.default\n  }\n\n  output += `\\nüí° ${suggestionText}`\n\n  return output\n}\n\n/**\n * Formats a validation error\n */\nexport function formatValidationError(opts: {\n  item: string\n  errors: string[]\n  suggestion?: string\n}): string {\n  const { item, errors, suggestion } = opts\n\n  let output = `‚ö†Ô∏è  Validation failed for ${item}:`\n  errors.forEach((err) => {\n    output += `\\n  - ${err}`\n  })\n\n  if (suggestion) {\n    output += `\\nüí° ${suggestion}`\n  }\n\n  return output\n}\n\n/**\n * Extracts the most relevant error message from a stack of errors\n * @param error - The error to extract a message from\n * @param isVerbose - Whether verbose mode is already enabled (to avoid suggesting --verbose when it's already on)\n */\nexport function extractErrorMessage(error: unknown, isVerbose = false): string {\n  if (error instanceof Error) {\n    // Check if it's a Zod error by checking for issues property\n    if ('issues' in error && Array.isArray((error as any).issues)) {\n      const issues = (error as any).issues\n      const errorMessages = issues.map((issue: any) => {\n        // Format path with bracket notation for array indices\n        const path = issue.path\n          .map((segment: string | number, index: number) => {\n            if (typeof segment === 'number') {\n              return `[${segment}]`\n            }\n            return index === 0 ? segment : `.${segment}`\n          })\n          .join('')\n        return `${issue.message} at \"${path}\"`\n      })\n      const baseMessage = `Validation error: ${errorMessages.join('; ')}.`\n      // Only suggest --verbose if it's not already enabled\n      return isVerbose\n        ? baseMessage\n        : `${baseMessage} Try re-running the command with --verbose for more information.`\n    }\n    return error.message\n  }\n  if (typeof error === 'string') {\n    return error\n  }\n  return String(error)\n}\n"]}