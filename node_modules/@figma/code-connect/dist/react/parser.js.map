{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../src/react/parser.ts"],"names":[],"mappings":"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","sourcesContent":["import ts from 'typescript'\nimport {\n  CodeConnectParser,\n  DEFAULT_LABEL_PER_PARSER,\n  getRemoteFileUrl,\n  mapImportPath,\n  mapImportSpecifier,\n} from '../connect/project'\nimport { SyntaxHighlightLanguage } from '../connect/label_language_mapping'\nimport { logger } from '../common/logging'\nimport {\n  bfsFindNode,\n  getTagName,\n  stripQuotesFromNode,\n  parsePropertyOfType,\n  parseFunctionArgument,\n  isOneOf,\n} from '../typescript/compiler'\nimport { FIGMA_CONNECT_CALL, PropMappings, parsePropsObject } from '../connect/intrinsics'\nimport { CodeConnectJSON } from '../connect/figma_connect'\nimport { getParsedTemplateHelpersString } from './parser_template_helpers'\nimport {\n  getPositionInSourceFile,\n  InternalError,\n  makeCreatePropPlaceholder,\n  ParserContext,\n  ParserError,\n  visitPropReferencingNode,\n  getReferencedPropsForTemplate,\n  findDescendants,\n  parseLinks,\n  parseVariant,\n  parseImports,\n  ParseOptions,\n} from '../connect/parser_common'\n\n/**\n * Traverses the AST and returns the first JSX element it finds\n * @param node AST node\n * @returns\n */\nexport function findJSXElement(\n  node: ts.Node,\n): ts.JsxElement | ts.JsxSelfClosingElement | ts.JsxFragment | undefined {\n  if (ts.isJsxElement(node) || ts.isJsxFragment(node) || ts.isJsxSelfClosingElement(node)) {\n    return node\n  } else {\n    return ts.forEachChild(node, findJSXElement)\n  }\n}\n\nfunction findBlock(node: ts.Node): ts.Block | undefined {\n  if (ts.isBlock(node)) {\n    return node\n  } else {\n    return ts.forEachChild(node, findBlock)\n  }\n}\n\n/**\n * Walks up the AST from an assignment to find the import declaration\n */\nfunction findParentImportDeclaration(\n  declaration: ts.Declaration,\n): ts.ImportDeclaration | undefined {\n  let current = declaration\n  while (current) {\n    if (ts.isImportDeclaration(current)) {\n      return current\n    }\n    current = current.parent as ts.Declaration\n  }\n}\n\nfunction getImportsOfModule(sourceFile: ts.SourceFile): ts.ImportDeclaration[] {\n  const imports: ts.ImportDeclaration[] = []\n\n  function visit(node: ts.Node) {\n    if (ts.isImportDeclaration(node)) {\n      imports.push(node)\n    }\n    ts.forEachChild(node, visit)\n  }\n\n  visit(sourceFile)\n\n  return imports\n}\n\nfunction resolveModuleSpecifier(\n  program: ts.Program,\n  sourceFile: ts.SourceFile,\n  importSpecifier: string,\n): string | undefined {\n  const compilerHost = ts.createCompilerHost(program.getCompilerOptions())\n  const moduleResolutionHost: ts.ModuleResolutionHost = {\n    fileExists: compilerHost.fileExists,\n    readFile: compilerHost.readFile,\n    directoryExists: compilerHost.directoryExists,\n    getCurrentDirectory: compilerHost.getCurrentDirectory,\n    getDirectories: compilerHost.getDirectories,\n  }\n\n  const resolvedModule = ts.resolveModuleName(\n    importSpecifier,\n    sourceFile.fileName,\n    program.getCompilerOptions(),\n    moduleResolutionHost,\n  )\n\n  return resolvedModule.resolvedModule?.resolvedFileName\n}\n\n// Traverse the source file and resolve imports\nexport function findAndResolveImports(program: ts.Program, sourceFile: ts.SourceFile) {\n  const importSpecifierToFilePath: Record<string, string> = {}\n  ts.forEachChild(sourceFile, (node) => {\n    if (ts.isImportDeclaration(node)) {\n      const importSpecifier = (node.moduleSpecifier as ts.StringLiteral).text\n      const resolvedFileName = resolveModuleSpecifier(program, sourceFile, importSpecifier)\n\n      if (resolvedFileName) {\n        importSpecifierToFilePath[importSpecifier] = resolvedFileName\n      }\n    }\n  })\n  return importSpecifierToFilePath\n}\n\n/**\n * Finds all import statements in a file that matches the given identifiers\n *\n * @param parserContext Parser context\n * @param identifiers List of identifiers to find imports for\n * @returns\n */\nfunction getSourceFilesOfImportedIdentifiers(parserContext: ParserContext, _identifiers: string[]) {\n  const { sourceFile, resolvedImports } = parserContext\n  const importDeclarations = getImportsOfModule(sourceFile)\n  const imports: {\n    statement: string\n    file: string\n    moduleSpecifier: string\n  }[] = []\n\n  const identifiers = _identifiers.map((identifier) => identifier.split('.')[0])\n\n  for (const declaration of importDeclarations) {\n    let statement = declaration.getText()\n    // remove the quotation marks around the module specifier\n    const moduleSpecifier = declaration.moduleSpecifier.getText().slice(1, -1)\n\n    if (declaration.importClause) {\n      // Default imports\n      if (declaration.importClause.name) {\n        const identifier = declaration.importClause.name.text\n\n        if (identifiers.includes(identifier)) {\n          imports.push({\n            statement,\n            file: resolvedImports[moduleSpecifier],\n            moduleSpecifier,\n          })\n        }\n      }\n\n      if (declaration.importClause.namedBindings) {\n        const namedBindings = declaration.importClause.namedBindings\n\n        if (ts.isNamedImports(namedBindings)) {\n          // Named imports (import { x, y } from 'module')\n          // filter out any unused imports from the statement the identifier belongs to\n          const elements = namedBindings.elements\n            .map((specifier) => specifier.name.text)\n            .filter((name) => identifiers.includes(name))\n\n          if (elements.length > 0) {\n            imports.push({\n              statement: statement.replace(/{.*}/s, `{ ${elements.join(', ')} }`),\n              file: resolvedImports[moduleSpecifier],\n              moduleSpecifier,\n            })\n          }\n        } else if (ts.isNamespaceImport(namedBindings)) {\n          // Namespace import (import * as name from 'module')\n          const identifier = namedBindings.name.text\n          if (identifiers.includes(identifier)) {\n            imports.push({\n              statement,\n              file: resolvedImports[moduleSpecifier],\n              moduleSpecifier,\n            })\n          }\n        }\n      }\n    }\n  }\n\n  return imports\n}\n\nexport type ComponentTypeSignature = Record<string, string>\n\n/**\n * Extract metadata about the referenced React component. Used by both the\n * Code Connect and Storybook commands.\n *\n * @param parserContext Parser context\n * @param componentSymbol The ts.Symbol from the metadata referencing the\n * component being documented\n * @param node The node being parsed. Used for error logging.\n * @returns Metadata object\n */\nexport async function parseComponentMetadata(\n  node: ts.PropertyAccessExpression | ts.Identifier | ts.Expression,\n  parserContext: ParserContext,\n  silent?: boolean,\n) {\n  const { checker, sourceFile } = parserContext\n  let componentSymbol = checker.getSymbolAtLocation(node)\n  let componentSourceFile = sourceFile\n  let component = ''\n  let componentDeclaration\n\n  // Hacky fix for namespaced components, this probably doesn't work for storybook\n  if (ts.isPropertyAccessExpression(node)) {\n    componentSymbol = checker.getSymbolAtLocation(node.expression)\n    if (!componentSymbol) {\n      throw new ParserError(`Could not find symbol for component ${node.expression.getText()}`, {\n        sourceFile,\n        node,\n      })\n    }\n  }\n\n  // Component declared in a different file\n  if (\n    componentSymbol &&\n    componentSymbol.declarations &&\n    (ts.isImportSpecifier(componentSymbol.declarations[0]) ||\n      ts.isImportClause(componentSymbol.declarations[0]))\n  ) {\n    let importDeclaration = findParentImportDeclaration(componentSymbol.declarations[0])\n    if (!importDeclaration) {\n      throw new ParserError(\n        'No import statement found for component, make sure the component is imported',\n        {\n          sourceFile,\n          node,\n        },\n      )\n    }\n\n    // The component should be imported from another file, we need to follow the\n    // aliased symbol to get the correct function definition\n    if (componentSymbol.flags & ts.SymbolFlags.Alias) {\n      componentSymbol = checker.getAliasedSymbol(componentSymbol)\n    }\n\n    if (!componentSymbol || !componentSymbol.declarations) {\n      if (!silent) {\n        logger.warn(\n          `Import for ${node.getText()} could not be resolved, make sure that your \\`include\\` globs in \\`figma.config.json\\` matches the component source file (in addition to the Code Connect file). If you're using path aliases, make sure to include the same aliases in \\`figma.config.json\\` with the \\`paths\\` option.`,\n        )\n      }\n      return {\n        source: '',\n        line: 0,\n        component: node.getText(),\n      }\n    }\n\n    // If we haven't found the component declaration by now, it's likely because it's\n    // assigned to an object/namespace, for example: `export const Button = { Primary: () => <button /> }`,\n    // so we need to find the function declaration by traversing the AST in that file.\n    if (!ts.isFunctionDeclaration(componentSymbol.declarations[0])) {\n      const sourceFile = componentSymbol.declarations[0].getSourceFile()\n      bfsFindNode(sourceFile, sourceFile, (node) => {\n        if (\n          (ts.isFunctionDeclaration(node) || ts.isVariableDeclaration(node)) &&\n          node.name &&\n          componentSymbol?.name &&\n          node.name.getText() === componentSymbol.name\n        ) {\n          componentSymbol = checker.getSymbolAtLocation(node.name)\n          return true\n        }\n        return false\n      })\n    }\n\n    componentDeclaration = componentSymbol.declarations[0]\n    componentSourceFile = componentDeclaration.getSourceFile()\n  } else {\n    componentDeclaration = componentSymbol?.declarations?.[0]\n  }\n\n  const source = componentSourceFile.fileName\n\n  if (!source) {\n    throw new InternalError(\n      `Could not find source file for component ${component} - is this file included in the directory passed to \\`figma connect <dir>\\`?`,\n    )\n  }\n\n  if (!componentDeclaration) {\n    throw new ParserError(`Could not find declaration for component ${component}`, {\n      sourceFile,\n      node,\n    })\n  }\n\n  const line = getPositionInSourceFile(componentDeclaration, componentSourceFile).line\n  if (line === undefined) {\n    throw new InternalError(\n      `Could not determine line number for component ${componentDeclaration.getStart(sourceFile)}`,\n    )\n  }\n\n  return {\n    source,\n    line,\n    component: node.getText(),\n  }\n}\n\n/**\n * Parses a render function and ouputs a template string, extracting the code and\n * any import statements matching the JSX elements used in the function body\n *\n * @param exp A function or arrow function expression\n * @param parserContext Parser context\n * @param propMappings Prop mappings object as returned by parseProps\n *\n * @returns The code of the render function and a list of imports\n */\nexport function parseRenderFunctionExpression(\n  exp: ts.ArrowFunction | ts.FunctionExpression | ts.FunctionDeclaration,\n  parserContext: ParserContext,\n  propMappings?: PropMappings,\n) {\n  const { sourceFile } = parserContext\n\n  let renderFunctionCode: string\n\n  if (exp.parameters.length > 1) {\n    throw new ParserError(\n      `Expected a single props parameter for the render function, got ${exp.parameters.length} parameters`,\n      { sourceFile, node: exp },\n    )\n  }\n\n  const propsParameter = exp.parameters[0]\n\n  // Keep track of any props which are referenced in the example\n  const referencedProps = new Set<string>()\n\n  const createPropPlaceholder = makeCreatePropPlaceholder({\n    propMappings,\n    referencedProps,\n    sourceFile,\n  })\n\n  // Find all property access expressions in the function body and replace them\n  // with a function call like `__PROP__(\"propName\")`, so that we can easily\n  // find them in the next step to convert them into\n  // `${_fcc_renderReactProp(...)` in the template string.\n  //\n  // Doing it this way means we can normalize the different ways in which props\n  // can be accessed using the compiler API, which is much easier than using a\n  // regex, then in the next step we can use a simple regex to convert that into\n  // the template string.\n  if (propsParameter) {\n    exp = ts.transform(exp, [\n      (context) => (rootNode) => {\n        function visit(node: ts.Node): ts.Node {\n          const visitResult = visitPropReferencingNode({\n            propsParameter,\n            node,\n            createPropPlaceholder,\n            useJsx: true,\n          })\n\n          if (visitResult) {\n            return visitResult\n          }\n\n          // object assignment using destructured reference, e.g `prop={{ key: value }}`\n          // (`{{ key: props.value }}` syntax will be captured by the `props.` notation branch above)\n          if (\n            ts.isObjectBindingPattern(propsParameter.name) &&\n            ts.isPropertyAssignment(node) &&\n            ts.isIdentifier(node.initializer) &&\n            propsParameter.name.elements.find((el) =>\n              node.initializer.getText().startsWith(el.name.getText()),\n            )\n          ) {\n            return ts.factory.createPropertyAssignment(\n              node.name,\n              createPropPlaceholder({ name: node.initializer.getText(), node }),\n            )\n          }\n          // object assignment using destructured reference as a shorthand, e.g `prop={{ value }}`\n          if (\n            ts.isObjectBindingPattern(propsParameter.name) &&\n            ts.isShorthandPropertyAssignment(node) &&\n            propsParameter.name.elements.find((el) =>\n              node.name.getText().startsWith(el.name.getText()),\n            )\n          ) {\n            return ts.factory.createPropertyAssignment(\n              node.name,\n              createPropPlaceholder({ name: node.name.getText(), node }),\n            )\n          }\n\n          // Replaces {...props} with all the prop mapped props we know about,\n          // e.g. <Button {...props} /> becomes:\n          // <Button prop1={__PROP__(\"prop1\")} prop2={__PROP__(\"prop2\")} />.\n          if (\n            ts.isJsxSpreadAttribute(node) &&\n            ts.isIdentifier(node.expression) &&\n            // example: (props) => (...)\n            (node.expression.getText() === propsParameter.name.getText() ||\n              // example: ({ prop1, prop2 ...props }) => (...)\n              (ts.isObjectBindingPattern(propsParameter.name) &&\n                propsParameter.name.elements.find(\n                  (el) => el.dotDotDotToken && el.name.getText() === node.expression?.getText(),\n                )))\n          ) {\n            // if we have an object binding pattern ({ prop1, prop2 ...props }),\n            // exclude the props that are already destructured (prop1, prop2)\n            const propsToExclude = ts.isObjectBindingPattern(propsParameter.name)\n              ? propsParameter.name.elements\n                  .filter((el) => !el.dotDotDotToken)\n                  .map((el) => el.name.getText())\n              : []\n            const props = propMappings\n              ? Object.keys(propMappings)\n                  .filter((prop) => !propsToExclude.includes(prop))\n                  .map((prop) => {\n                    return ts.factory.createJsxAttribute(\n                      ts.factory.createIdentifier(prop),\n                      createPropPlaceholder({\n                        name: prop,\n                        node,\n                        wrapInJsxExpression: true,\n                      }) as ts.JsxExpression,\n                    )\n                  })\n              : []\n\n            if (propMappings) {\n              for (const key of Object.keys(propMappings)) {\n                referencedProps.add(key)\n              }\n            }\n\n            return props as any\n          }\n\n          return ts.visitEachChild(node, visit, context)\n        }\n        return ts.visitNode(rootNode, visit) as\n          | ts.ArrowFunction\n          | ts.FunctionExpression\n          | ts.FunctionDeclaration\n      },\n    ]).transformed[0] as typeof exp\n  }\n\n  const printer = ts.createPrinter()\n  const block = findBlock(exp)\n  let nestable = false\n  let jsx = findJSXElement(exp)\n\n  if (jsx && (!block || (block && block.statements.length <= 1))) {\n    // The function body is a single JSX element\n    renderFunctionCode = printer.printNode(ts.EmitHint.Unspecified, jsx, sourceFile)\n    nestable = true\n  } else if (block) {\n    // The function body has more stuff in it, so we wrap the body in a function\n    // expression. Why not just print the exact function passed to `render`?\n    // Because the parameters to that function are not actually referenced in\n    // the rendered code snippet in Figma - they're mapped to values on the\n    // Figma instance.\n    const functionName = 'Example'\n    const functionExpression = ts.factory.createFunctionExpression(\n      undefined,\n      undefined,\n      ts.factory.createIdentifier(functionName),\n      [],\n      undefined,\n      undefined,\n      block,\n    )\n    const printer = ts.createPrinter()\n    renderFunctionCode = printer.printNode(ts.EmitHint.Unspecified, functionExpression, sourceFile)\n  } else {\n    throw new ParserError(\n      `Expected a single JSX element or a block statement in the render function, got ${exp.getText()}`,\n      { sourceFile, node: exp },\n    )\n  }\n\n  renderFunctionCode = replacePropPlaceholders(renderFunctionCode)\n\n  // Escape backticks from the example code, as otherwise those would terminate the `figma.tsx` template literal\n  renderFunctionCode = renderFunctionCode.replace(/`/g, '\\\\`')\n\n  // Finally, output the render function as a figma.tsx call\n  const figmaTsxCall = `figma.tsx\\`${renderFunctionCode}\\``\n\n  // Find all JSX elements in the function body and extract their import\n  // statements\n  const jsxTags = findDescendants(\n    exp,\n    (element) => ts.isJsxElement(element) || ts.isJsxSelfClosingElement(element),\n  ) as (ts.JsxElement | ts.JsxSelfClosingElement)[]\n  const imports = getSourceFilesOfImportedIdentifiers(parserContext, jsxTags.map(getTagName))\n\n  return {\n    code: figmaTsxCall,\n    imports,\n    nestable,\n    referencedProps,\n  }\n}\n\n/**\n * Parses the render function passed to `figma.connect()`, extracting the code and\n * any import statements matching the JSX elements used in the function body\n *\n * @param exp A function or arrow function expression\n * @param parserContext Parser context\n * @param propMappings Prop mappings object as returned by parseProps\n *\n * @returns The code of the render function and a list of imports\n */\nexport function parseJSXRenderFunction(\n  exp: ts.ArrowFunction | ts.FunctionExpression | ts.FunctionDeclaration,\n  parserContext: ParserContext,\n  propMappings?: PropMappings,\n  skipTemplateHelpers?: boolean,\n) {\n  const { sourceFile } = parserContext\n\n  const { code, imports, nestable, referencedProps } = parseRenderFunctionExpression(\n    exp,\n    parserContext,\n    propMappings,\n  )\n\n  let templateCode = ''\n\n  // Generate the template code\n  // Inject React-specific template helper functions\n  if (!skipTemplateHelpers) {\n    templateCode = getParsedTemplateHelpersString() + '\\n\\n'\n  }\n\n  // Require the template API\n  templateCode += `const figma = require('figma')\\n\\n`\n\n  // Then we output `const propName = figma.properties.<kind>('propName')` calls\n  // for each referenced prop, so these are accessible to the template code.\n  templateCode += getReferencedPropsForTemplate({\n    propMappings,\n    exp,\n    sourceFile,\n  })\n\n  const includeMetadata = propMappings && Object.keys(propMappings).length > 0\n\n  // Finally, output the example code\n  templateCode += includeMetadata\n    ? `export default { ...${code}, metadata: { __props } }\\n`\n    : `export default ${code}\\n`\n\n  return {\n    code: templateCode,\n    imports,\n    nestable,\n  }\n}\n\n/**\n * Parses the render function for a value (i.e. example which returns a string or React\n * component reference, not JSX) passed to `figma.connect()`\n */\nexport function parseValueRenderFunction(\n  exp: ts.ArrowFunction | ts.FunctionExpression | ts.FunctionDeclaration,\n  parserContext: ParserContext,\n  propMappings?: PropMappings,\n  skipTemplateHelpers?: boolean,\n) {\n  const { sourceFile } = parserContext\n  const printer = ts.createPrinter()\n  if (!exp.body) {\n    throw new ParserError('Expected a function body', {\n      sourceFile: parserContext.sourceFile,\n      node: exp,\n    })\n  }\n\n  let exampleCode = printer.printNode(ts.EmitHint.Unspecified, exp.body, sourceFile)\n  const nestable = true\n\n  let templateCode = ''\n  // Generate the template code\n  // Inject React-specific template helper functions\n  if (!skipTemplateHelpers) {\n    templateCode = getParsedTemplateHelpersString() + '\\n\\n'\n  }\n\n  // Require the template API\n  templateCode += `const figma = require('figma')\\n\\n`\n\n  // Then we output `const propName = figma.properties.<kind>('propName')` calls\n  // for each referenced prop, so these are accessible to the template code.\n  templateCode += getReferencedPropsForTemplate({\n    propMappings,\n    exp,\n    sourceFile,\n  })\n\n  // Escape backticks from the example code\n  exampleCode = exampleCode.replace(/`/g, '\\\\`')\n\n  let imports: {\n    statement: string\n    file: string\n    moduleSpecifier: string\n  }[] = []\n\n  const includeMetadata = propMappings && Object.keys(propMappings).length > 0\n\n  if (ts.isStringLiteral(exp.body)) {\n    // The value is a string, which is already wrapped in quotes\n    templateCode += includeMetadata\n      ? `export default { ...figma.value(${exampleCode}), metadata: { __props } }\\n`\n      : `export default figma.value(${exampleCode})\\n`\n  } else if (ts.isIdentifier(exp.body)) {\n    // The value is an identifier, i.e. a React component reference\n    const value = `_fcc_reactComponent(\"${exp.body.getText()}\")`\n    const preview = `_fcc_renderPropValue(${value})`\n    templateCode += includeMetadata\n      ? `export default { ...figma.value(${value}, ${preview}), metadata: { __props } }\\n`\n      : `export default figma.value(${value}, ${preview})\\n`\n    imports = getSourceFilesOfImportedIdentifiers(parserContext, [exp.body.getText()])\n  }\n\n  return {\n    code: templateCode,\n    imports,\n    nestable,\n  }\n}\n\nexport function replacePropPlaceholders(exampleCode: string) {\n  // Replace React prop placeholders we inserted above (like\n  // `reactPropName={__PROP__(\"figmaPropName\")}`) with calls to\n  // _fcc_renderReactProp, which renders them correctly (see\n  // parser_template_helpers.ts)\n  exampleCode = exampleCode.replace(\n    // match \" reactPropName={__PROP__(\"figmaPropName\")}\" and extract the names\n    // We allow hyphens in prop names (unlike React) to support rendering HTML attributes\n    / ([A-Za-z0-9\\-]+)=\\{__PROP__\\(\"([A-Za-z0-9_\\.]+)\"\\)\\}/g,\n    (_match, reactPropName, figmaPropName) => {\n      return `\\${_fcc_renderReactProp('${reactPropName}', ${figmaPropName})}`\n    },\n  )\n\n  // Replace React children placeholders like `${__PROP__(\"propName\")}` with\n  // calls to _fcc_renderReactChildren, which renders them correctly (see\n  // parser_template_helpers.ts)\n  exampleCode = exampleCode.replace(\n    /\\{__PROP__\\(\"([A-Za-z0-9_\\.]+)\"\\)\\}/g,\n    (_match, figmaPropName) => {\n      return `\\${_fcc_renderReactChildren(${figmaPropName})}`\n    },\n  )\n\n  // Assume any remaining placeholders are values, e.g.\n  // - { prop: __PROP__(\"propName\") }\n  // - useState(__PROP__(\"propName\"))\n  // These never need special treatment based on their type.\n  return exampleCode.replace(/__PROP__\\(\"([A-Za-z0-9_\\.]+)\"\\)/g, (_match, figmaPropName) => {\n    return `\\${_fcc_renderPropValue(${figmaPropName})}`\n  })\n}\n\nfunction followIdentifierToStringLiteralDeclaration(\n  node: ts.Identifier | ts.StringLiteral,\n  parserContext: ParserContext,\n  errMessage: string,\n) {\n  const { checker } = parserContext\n  let result = node\n\n  if (node && ts.isIdentifier(node)) {\n    const symbol = checker.getSymbolAtLocation(node)\n    if (symbol) {\n      const decl = symbol.valueDeclaration\n      if (\n        decl &&\n        ts.isVariableDeclaration(decl) &&\n        decl.initializer &&\n        ts.isStringLiteral(decl.initializer)\n      ) {\n        result = decl.initializer\n      }\n    }\n  }\n\n  // If we followed the identifier to its declaration and it's not a string literal,\n  // throw an error\n  if (!result || !ts.isStringLiteral(result)) {\n    throw new ParserError(errMessage, {\n      node: result,\n      sourceFile: parserContext.sourceFile,\n    })\n  }\n\n  return result\n}\n\nfunction parseFigmaConnectArgs(node: ts.CallExpression, parserContext: ParserContext) {\n  const required = true\n  const first = parseFunctionArgument(\n    node,\n    parserContext,\n    0,\n    isOneOf([ts.isIdentifier, ts.isPropertyAccessExpression, ts.isStringLiteral]),\n    required,\n    `\\`${FIGMA_CONNECT_CALL}\\` must be called with a reference to a Component or a Figma Component URL as the first argument. Example usage:\n  \\`${FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1')\\``,\n  )!\n\n  let figmaNodeUrlArg: ts.StringLiteral\n  let componentArg: ts.Identifier | ts.PropertyAccessExpression | undefined\n  let configObjArgIndex\n\n  // This function has two signatures. If the first arg is a string literal, it's the Figma node URL, and\n  // it won't have a component reference.\n  if (ts.isStringLiteral(first)) {\n    figmaNodeUrlArg = first\n    componentArg = undefined\n    configObjArgIndex = 1\n  } else {\n    // If the first argument is not a string literal, it must be a component reference,\n    // and the second argument must be the Figma node URL\n    componentArg = first\n    configObjArgIndex = 2\n\n    const invalidTypeErrorMsg = `The second argument to ${FIGMA_CONNECT_CALL}() must be a string literal (the URL of the Figma node). Example usage:\n    \\`${FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1')\\``\n\n    let arg = parseFunctionArgument(\n      node,\n      parserContext,\n      1,\n      isOneOf([ts.isIdentifier, ts.isStringLiteral]),\n      required,\n      invalidTypeErrorMsg,\n    )!\n\n    figmaNodeUrlArg = followIdentifierToStringLiteralDeclaration(\n      arg,\n      parserContext,\n      invalidTypeErrorMsg,\n    )\n  }\n\n  const configObjArg = parseFunctionArgument(\n    node,\n    parserContext,\n    configObjArgIndex,\n    ts.isObjectLiteralExpression,\n    false /* not required */,\n    `The third argument to ${FIGMA_CONNECT_CALL}() must be an object literal. Example usage:\n    \\`${FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1', { render: () => <Button /> })\\``,\n  )\n\n  return {\n    componentArg,\n    figmaNodeUrlArg,\n    configObjArg,\n  }\n}\n\nfunction parseConfigObjectArg(\n  configArg: ts.ObjectLiteralExpression | undefined,\n  parserContext: ParserContext,\n) {\n  if (!configArg) {\n    return {\n      propsArg: undefined,\n      exampleArg: undefined,\n      variantArg: undefined,\n      importsArg: undefined,\n      linksArg: undefined,\n    }\n  }\n\n  const propsArg = parsePropertyOfType({\n    objectLiteralNode: configArg,\n    propertyName: 'props',\n    predicate: ts.isObjectLiteralExpression,\n    parserContext,\n    required: false,\n    errorMessage: `The 'props' property must be an object literal. Example usage:\n      \\`${FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1', {\n        props: {\n          disabled: figma.boolean('Disabled'),\n          text: figma.string('TextContent'),\n        }\n      })\\``,\n  })\n\n  const exampleArg = parsePropertyOfType({\n    objectLiteralNode: configArg,\n    propertyName: 'example',\n    predicate: isOneOf([ts.isArrowFunction, ts.isFunctionExpression]),\n    parserContext,\n    required: false,\n    errorMessage: `The 'example' property must be an inline function or arrow function. Example usage:\n    \\`${FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1', {\n      example: () => <Button />\n    })\\``,\n  })\n\n  const variantArg = parsePropertyOfType({\n    objectLiteralNode: configArg,\n    propertyName: 'variant',\n    predicate: ts.isObjectLiteralExpression,\n    parserContext,\n    required: false,\n    errorMessage: `The 'variant' property must be an object literal. Example usage:\n    \\`${FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1', {\n      variant: {\n        \"Has Icon\": true\n      }\n    })\\``,\n  })\n\n  const linksArg = parsePropertyOfType({\n    objectLiteralNode: configArg,\n    propertyName: 'links',\n    predicate: ts.isArrayLiteralExpression,\n    parserContext,\n    required: false,\n    errorMessage: `The 'links' property must be an array literal. Example usage:\n    \\`${FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1', {\n      links: [\n        { name: 'Storybook', url: 'https://storybook.com' }\n      ]\n    })\\``,\n  })\n\n  const importsArg = parsePropertyOfType({\n    objectLiteralNode: configArg,\n    propertyName: 'imports',\n    predicate: ts.isArrayLiteralExpression,\n    parserContext,\n    required: false,\n    errorMessage: `The 'imports' property must be an array literal. Example usage:\n    \\`${FIGMA_CONNECT_CALL}(Button, 'https://www.figma.com/file/123?node-id=1-1', {\n      imports: ['import { Button } from \"./Button\"']\n    })\\``,\n  })\n\n  return {\n    propsArg,\n    exampleArg,\n    variantArg,\n    linksArg,\n    importsArg,\n  }\n}\n\nexport function getDefaultTemplate(\n  componentMetadata: Awaited<ReturnType<typeof parseComponentMetadata>>,\n) {\n  const example = `<${componentMetadata.component} />`\n  return `const figma = require(\"figma\")\\n\\nexport default figma.tsx\\`${example}\\``\n}\n\nexport async function parseReactDoc(\n  node: ts.CallExpression,\n  parserContext: ParserContext,\n  { repoUrl, silent, skipTemplateHelpers }: ParseOptions,\n): Promise<CodeConnectJSON> {\n  const { checker, sourceFile, config } = parserContext\n\n  // Parse the arguments to the `figma.connect()` call\n  const { componentArg, figmaNodeUrlArg, configObjArg } = parseFigmaConnectArgs(node, parserContext)\n\n  const { propsArg, exampleArg, variantArg, linksArg, importsArg } = parseConfigObjectArg(\n    configObjArg,\n    parserContext,\n  )\n\n  let figmaNode = stripQuotesFromNode(figmaNodeUrlArg)\n  // TODO This logic is duplicated in connect.ts transformDocFromParser due to some type issues\n  if (config.documentUrlSubstitutions) {\n    Object.entries(config.documentUrlSubstitutions).forEach(([from, to]) => {\n      // @ts-expect-error\n      figmaNode = figmaNode.replace(from, to)\n    })\n  }\n  const metadata = componentArg\n    ? await parseComponentMetadata(componentArg, parserContext, silent)\n    : undefined\n\n  const props = propsArg ? parsePropsObject(propsArg, parserContext) : undefined\n  const render = exampleArg\n    ? findJSXElement(exampleArg)\n      ? parseJSXRenderFunction(exampleArg, parserContext, props, skipTemplateHelpers)\n      : parseValueRenderFunction(exampleArg, parserContext, props, skipTemplateHelpers)\n    : undefined\n  const variant = variantArg ? parseVariant(variantArg, sourceFile, checker) : undefined\n  const links = linksArg ? parseLinks(linksArg, parserContext) : undefined\n\n  let mappedImports: string[]\n  if (importsArg) {\n    mappedImports = parseImports(importsArg, parserContext)\n  } else {\n    // If no template function was provided, construct one and add the import\n    // statement for the component\n    let imports = render?.imports\n      ? render.imports\n      : metadata !== undefined\n        ? getSourceFilesOfImportedIdentifiers(parserContext, [metadata.component])\n        : []\n\n    if (imports.length === 0 && metadata?.component) {\n      // If no imports were found, it might mean that the component is not imported, or\n      // that the `figma.connect` call is in the same file as the component. In the latter\n      // case - we'll want to generate one\n      const fileName = metadata.source.split('/').pop()?.split('.')[0]\n      const relativeImportPath = `./${fileName}`\n      imports = [\n        {\n          statement: `import { ${metadata.component} } from '${relativeImportPath}'`,\n          file: sourceFile.fileName,\n          moduleSpecifier: relativeImportPath,\n        },\n      ]\n    }\n\n    mappedImports = [\n      ...new Set(\n        imports.map((imp) => {\n          if (config) {\n            // First try to map the original import specifier directly (preserves user's intent)\n            // e.g., '@/AlertTitle' -> '@acme/package/AlertTitle'\n            if (typeof imp.moduleSpecifier === 'string') {\n              const mappedFromSpecifier = mapImportSpecifier(imp.moduleSpecifier, config)\n              if (mappedFromSpecifier) {\n                return imp.statement.replace(\n                  /['\"]([@\\.\\/a-zA-Z0-9_-]*)['\"]/,\n                  `'${mappedFromSpecifier}'`,\n                )\n              }\n            }\n            // Fall back to mapping based on resolved file path (for relative imports)\n            const mappedPath = mapImportPath(imp.file, config)\n            if (mappedPath) {\n              return imp.statement.replace(/['\"]([@\\.\\/a-zA-Z0-9_-]*)['\"]/, `'${mappedPath}'`)\n            }\n          }\n          return imp.statement\n        }),\n      ),\n    ]\n  }\n\n  if (mappedImports.length === 0 && metadata?.component) {\n    logger.warn(\n      `The import statement for ${metadata.component} could not be automatically resolved, make sure the component is imported (if not colocating) and that the path mappings are correct in your figma.config.json`,\n    )\n  }\n\n  let template\n  if (render?.code) {\n    template = render.code\n  } else if (metadata) {\n    template = getDefaultTemplate(metadata)\n  } else {\n    throw new ParserError(\n      `${FIGMA_CONNECT_CALL}() requires either a component argument or an example function`,\n      { sourceFile, node },\n    )\n  }\n\n  return {\n    figmaNode,\n    label: DEFAULT_LABEL_PER_PARSER.react!,\n    language: SyntaxHighlightLanguage.TypeScript,\n    component: metadata?.component,\n    source: metadata?.source ? getRemoteFileUrl(metadata.source, repoUrl) : '',\n    sourceLocation: metadata?.line !== undefined ? { line: metadata.line } : { line: -1 },\n    variant,\n    template,\n    templateData: {\n      // TODO: `props` here is currently only used for validation purposes,\n      // we should eventually remove it from the JSON payload\n      props,\n      imports: mappedImports,\n      // If there's no render function, the default example is always nestable\n      nestable: render ? render.nestable : true,\n    },\n    links,\n    metadata: {\n      cliVersion: require('../../package.json').version,\n    },\n  }\n}\n"]}