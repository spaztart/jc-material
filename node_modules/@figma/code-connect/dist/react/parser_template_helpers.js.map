{"version":3,"file":"parser_template_helpers.js","sourceRoot":"","sources":["../../src/react/parser_template_helpers.ts"],"names":[],"mappings":"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","sourcesContent":["/* istanbul ignore file */\n// This file needs to be ignored from code coverage, as Istanbul adds extra calls\n// to `cov_*` functions which are used to track coverage, but these functions\n// can't be resolved when executing the templates from the unit tests inside\n// `new Function()`\n\ndeclare const figma: { tsx: (template: TemplateStringsArray, ...args: any[]) => string }\ndeclare type CodeSection = { type: 'CODE'; code: string }\ndeclare type InstanceSection = { type: 'INSTANCE' }\ndeclare type SlotSection = { type: 'SLOT' }\ndeclare type ErrorSection = { type: 'ERROR' }\n\n// This file contains helper functions which hare included in the React template\n// example - i.e. they are run on the client side, but are not part of the\n// general template API as they are React specific.\n//\n// We write them in TS rather than as a string for maintainability, then call\n// `.toString()` on the functions and return a string we can inject. Note that\n// comments will be stripped, as this is run through the build step first.\n\n// The parser serializes all enum values to strings when passing them to the\n// template. To preserve type information, we wrap any complex types with a\n// `type` field so we can determine how to render the prop value correctly in\n// the template (when passed to e.g __fcc_renderReactProp), and also to\n// differentiate between things like template strings and identifiers (e.g\n// MyEnum.Something).\nexport type FCCValue =\n  | string\n  | number\n  | boolean\n  | undefined\n  | ReturnType<\n      | typeof _fcc_jsxElement\n      | typeof _fcc_function\n      | typeof _fcc_identifier\n      | typeof _fcc_object\n      | typeof _fcc_templateString\n      | typeof _fcc_reactComponent\n      | typeof _fcc_array\n    >\n\nexport function _fcc_array($value: any[]) {\n  return {\n    $value,\n    $type: 'array',\n  } as const\n}\n\nexport function _fcc_jsxElement($value: string) {\n  return {\n    $value,\n    $type: 'jsx-element',\n  } as const\n}\n\nexport function _fcc_function($value: string) {\n  return {\n    $value,\n    $type: 'function',\n  } as const\n}\n\nexport function _fcc_identifier($value: string) {\n  return {\n    $value,\n    $type: 'identifier',\n  } as const\n}\n\nexport function _fcc_object($value: Record<string, any>) {\n  return {\n    $value,\n    $type: 'object',\n    ...$value,\n  } as const\n}\n\nexport function _fcc_templateString($value: string) {\n  return {\n    $value,\n    $type: 'template-string',\n  } as const\n}\n\nexport function _fcc_reactComponent($value: string) {\n  return {\n    $value,\n    $type: 'react-component',\n  } as const\n}\n\nfunction isReactComponentArray(\n  prop: FCCValue | (CodeSection | InstanceSection | SlotSection | ErrorSection)[],\n): prop is (InstanceSection | SlotSection | CodeSection | ErrorSection)[] {\n  return (\n    Array.isArray(prop) &&\n    prop.every(\n      (item) =>\n        item.type === 'INSTANCE' ||\n        item.type === 'SLOT' ||\n        item.type === 'CODE' ||\n        item.type === 'ERROR',\n    )\n  )\n}\n\n// Render a prop value passed to an object literal based on its type.\n// for example: <Button sx={{ key: value }} />\nfunction _fcc_renderPropValue(\n  prop: FCCValue | (CodeSection | InstanceSection | SlotSection)[],\n): string | number | boolean | (CodeSection | InstanceSection | SlotSection)[] {\n  if (isReactComponentArray(prop)) {\n    return prop\n  }\n\n  if (prop === undefined) {\n    return 'undefined'\n  }\n\n  // Replace any newlines or quotes in the string with escaped versions\n  if (typeof prop === 'string') {\n    const str = `\"${prop.replaceAll('\\n', '\\\\n').replaceAll('\"', '\\\\\"')}\"`\n    if (str === '') {\n      return 'undefined'\n    } else {\n      return str\n    }\n  }\n\n  if (typeof prop === 'boolean' || typeof prop === 'number') {\n    return prop\n  }\n\n  if (\n    prop.$type === 'function' ||\n    prop.$type === 'identifier' ||\n    prop.$type === 'jsx-element' ||\n    prop.$type === 'react-component'\n  ) {\n    return prop.$value\n  }\n\n  if (prop.$type === 'array') {\n    return `[${prop.$value.map((el) => _fcc_renderPropValue(el))}]`\n  }\n\n  if (prop.$type === 'object') {\n    return `{${Object.keys(prop.$value)\n      .map((key) => ` ${key}: ${_fcc_renderPropValue(prop.$value[key])} `)\n      .join(',')}}`\n  }\n\n  if (prop.$type === 'template-string') {\n    return `\\`${prop.$value}\\``\n  }\n\n  return 'undefined'\n}\n\n// Render a React prop correctly, based on its type\nfunction _fcc_renderReactProp(\n  name: string,\n  prop: FCCValue | (CodeSection | InstanceSection | SlotSection | ErrorSection)[],\n) {\n  // If the value is an array, then it's an array of objects representing React\n  // children (either of type INSTANCE for pills, or CODE for inline code). The\n  // template string handler in the template API handles extracting the instance\n  // objects in a way the UI can handle.\n\n  if (isReactComponentArray(prop)) {\n    if (prop.length > 1) {\n      // If the array has multiple children, render them wrapped in braces and a\n      // fragment.\n      //\n      // We recursively call `figma.tsx` on the value as it itself is an array of\n      // CODE/INSTANCE sections, so we need to run it through the template string\n      // function otherwise this would just output `[object Object]` for the value.\n      // The template string handler function handles flattening nested arrays.\n      return figma.tsx` ${name}={<>${prop}</>}`\n    } else {\n      // Render a single child wrapped in braces, see above for why we use `figma.tsx`\n      return figma.tsx` ${name}={${prop}}`\n    }\n  }\n\n  // Render either the prop name or nothing for a boolean, we don't want to\n  // render `prop={true/false}`\n  if (typeof prop === 'boolean') {\n    return prop ? ` ${name}` : ''\n  }\n\n  // Replace any newlines or quotes in the string with escaped versions\n  if (typeof prop === 'string') {\n    const str = prop.replaceAll('\\n', '\\\\n').replaceAll('\"', '\\\\\"')\n    if (str === '') {\n      return ''\n    }\n    return ` ${name}=\"${str}\"`\n  }\n\n  if (typeof prop === 'number') {\n    return ` ${name}={${prop}}`\n  }\n\n  if (prop === undefined) {\n    return ''\n  }\n\n  if (\n    prop.$type === 'function' ||\n    prop.$type === 'identifier' ||\n    prop.$type === 'jsx-element' ||\n    prop.$type === 'react-component'\n  ) {\n    return ` ${name}={${prop.$value}}`\n  }\n\n  if (prop.$type === 'array' || prop.$type === 'object') {\n    return ` ${name}={${_fcc_renderPropValue(prop)}}`\n  }\n\n  if (prop.$type === 'template-string') {\n    return ` ${name}={\\`${prop.$value}\\`}`\n  }\n\n  return ''\n}\n\n// Renders React children correctly, based on their type\nfunction _fcc_renderReactChildren(\n  prop: FCCValue | (CodeSection | InstanceSection | SlotSection)[],\n) {\n  if (isReactComponentArray(prop)) {\n    return prop\n  }\n\n  if (typeof prop === 'string' || typeof prop === 'number' || typeof prop === 'boolean') {\n    return prop\n  }\n\n  if (prop === undefined) {\n    return ''\n  }\n\n  if (prop.$type === 'template-string') {\n    // If the value is a template string, wrap in braces\n    return figma.tsx`{\\`${prop.$value}\\`}`\n  }\n\n  // If the value is a JSX element, return it directly\n  if (prop.$type === 'jsx-element') {\n    return prop.$value\n  }\n\n  // but for other values, wrap in braces\n  if (prop.$type === 'function' || prop.$type === 'identifier') {\n    return `{${prop.$value}}`\n  }\n\n  if (prop.$type === 'array' || prop.$type === 'object') {\n    return `{${_fcc_renderPropValue(prop)}}`\n  }\n\n  if (prop.$type === 'react-component') {\n    return `<${prop.$value} />`\n  }\n}\n\nfunction _fcc_stringifyObject(obj: any): string {\n  if (Array.isArray(obj)) {\n    return `[${obj.map((element) => `${_fcc_stringifyObject(element)}`).join(',')}]`\n  }\n\n  if (typeof obj !== 'object' || obj instanceof Date || obj === null) {\n    return JSON.stringify(obj)\n  }\n\n  return `{${Object.keys(obj)\n    .map((key) => ` ${key}: ${_fcc_stringifyObject(obj[key])} `)\n    .join(',')}}`\n}\n\n// Return the helpers as a string which can be injected into the template\nexport function getParsedTemplateHelpersString() {\n  return [\n    _fcc_renderReactProp,\n    _fcc_renderReactChildren,\n    _fcc_jsxElement,\n    _fcc_function,\n    _fcc_identifier,\n    _fcc_object,\n    _fcc_templateString,\n    _fcc_renderPropValue,\n    _fcc_stringifyObject,\n    _fcc_reactComponent,\n    _fcc_array,\n    isReactComponentArray,\n  ]\n    .map((fn) => fn.toString())\n    .join('\\n')\n}\n"]}