{"version":3,"file":"parser_executable_types.js","sourceRoot":"","sources":["../../src/connect/parser_executable_types.ts"],"names":[],"mappings":";;;AAAA,6BAAuB;AAIvB,qEAAkE;AAclE,MAAM,gBAAgB,GAAG,OAAC,CAAC,MAAM,CAAC;IAChC,IAAI,EAAE,OAAC,CAAC,MAAM,EAAE;IAChB,GAAG,EAAE,OAAC,CAAC,MAAM,EAAE;CAChB,CAAC,CAAA;AAEW,QAAA,wBAAwB,GAAG,OAAC,CAAC,KAAK,CAC7C,OAAC,CAAC,MAAM,CAAC;IACP,yEAAyE;IACzE,4DAA4D;IAC5D,EAAE;IACF,uEAAuE;IACvE,0EAA0E;IAC1E,iEAAiE;IACjE,EAAE;IACF,qEAAqE;IACrE,YAAY;IACZ,KAAK,EAAE,OAAC,CAAC,KAAK,CAAC,CAAC,OAAC,CAAC,OAAO,CAAC,OAAO,CAAC,EAAE,OAAC,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,OAAC,CAAC,OAAO,CAAC,MAAM,CAAC,EAAE,OAAC,CAAC,OAAO,CAAC,OAAO,CAAC,CAAC,CAAC;IAC9F,4EAA4E;IAC5E,IAAI,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;IAC3B,OAAO,EAAE,OAAC,CAAC,MAAM,EAAE;IACnB,yEAAyE;IACzE,cAAc,EAAE,OAAC;SACd,MAAM,CAAC;QACN,IAAI,EAAE,OAAC,CAAC,MAAM,EAAE;QAChB,IAAI,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;KAC5B,CAAC;SACD,QAAQ,EAAE;CACd,CAAC,CACH,CAAA;AAED,+EAA+E;AAC/E,gCAAgC;AAChC,EAAE;AACF,gEAAgE;AAChE,6EAA6E;AAC7E,+EAA+E;AAC/E,4CAA4C;AAC/B,QAAA,oBAAoB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC3C,yDAAyD;IACzD,IAAI,EAAE,OAAC,CAAC,KAAK,CACX,OAAC,CAAC,MAAM,CAAC;QACP,sCAAsC;QACtC,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE;QACrB,kEAAkE;QAClE,mEAAmE;QACnE,SAAS,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;QAChC,iFAAiF;QACjF,OAAO,EAAE,OAAC,CAAC,MAAM,CAAC,OAAC,CAAC,GAAG,EAAE,CAAC,CAAC,QAAQ,EAAE;QACrC,sEAAsE;QACtE,wEAAwE;QACxE,0EAA0E;QAC1E,MAAM,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;QAC7B,+DAA+D;QAC/D,cAAc,EAAE,OAAC;aACd,MAAM,CAAC;YACN,yEAAyE;YACzE,yCAAyC;YACzC,IAAI,EAAE,OAAC,CAAC,MAAM,EAAE;SACjB,CAAC;aACD,QAAQ,EAAE;QACb,qFAAqF;QACrF,2CAA2C;QAC3C,oBAAoB,EAAE,OAAC,CAAC,MAAM,EAAE,CAAC,QAAQ,EAAE;QAC3C,+CAA+C;QAC/C,QAAQ,EAAE,OAAC,CAAC,MAAM,EAAE;QACpB,YAAY,EAAE,OAAC,CAAC,MAAM,CAAC;YACrB,wEAAwE;YACxE,uDAAuD;YACvD,EAAE;YACF,gFAAgF;YAChF,EAAE;YACF,wEAAwE;YACxE,sEAAsE;YACtE,kCAAkC;YAClC,KAAK,EAAE,OAAC,CAAC,MAAM,CAAC,OAAC,CAAC,MAAM,CAAC,EAAE,IAAI,EAAE,OAAC,CAAC,MAAM,EAAE,EAAE,IAAI,EAAE,OAAC,CAAC,GAAG,EAAE,EAAE,CAAQ,CAAC;YACrE,oEAAoE;YACpE,qEAAqE;YACrE,kEAAkE;YAClE,wEAAwE;YACxE,yEAAyE;YACzE,uEAAuE;YACvE,kEAAkE;YAClE,EAAE;YACF,0EAA0E;YAC1E,2EAA2E;YAC3E,6EAA6E;YAC7E,aAAa;YACb,OAAO,EAAE,OAAC,CAAC,KAAK,CAAC,OAAC,CAAC,MAAM,EAAE,CAAC,CAAC,QAAQ,EAAE;YACvC,0EAA0E;YAC1E,QAAQ,EAAE,OAAC,CAAC,OAAO,EAAE,CAAC,QAAQ,EAAE;SACjC,CAAC;QACF,8CAA8C;QAC9C,QAAQ,EAAE,OAAC,CAAC,UAAU,CAAC,gDAAuB,CAAC;QAC/C,6CAA6C;QAC7C,KAAK,EAAE,OAAC,CAAC,MAAM,EAAE;QACjB,qDAAqD;QACrD,iCAAiC;QACjC,KAAK,EAAE,OAAC,CAAC,KAAK,CAAC,gBAAgB,CAAC,CAAC,QAAQ,EAAE;KAC5C,CAA4C,CAC9C;IACD,gEAAgE;IAChE,QAAQ,EAAE,gCAAwB;CACnC,CAAC,CAAA;AA2GW,QAAA,qBAAqB,GAAG,OAAC,CAAC,MAAM,CAAC;IAC5C,8DAA8D;IAC9D,YAAY,EAAE,OAAC,CAAC,KAAK,CACnB,OAAC,CAAC,MAAM,CAAC;QACP,wCAAwC;QACxC,QAAQ,EAAE,OAAC,CAAC,MAAM,EAAE;KACrB,CAAC,CACH;IACD,iEAAiE;IACjE,QAAQ,EAAE,gCAAwB;CACnC,CAAC,CAAA","sourcesContent":["import { z } from 'zod'\nimport { ComponentTypeSignature } from '../react/parser'\nimport { BaseCodeConnectObject } from './figma_connect'\nimport { Intrinsic } from './intrinsics'\nimport { SyntaxHighlightLanguage } from './label_language_mapping'\n\nexport type ParseRequestPayload = {\n  mode: 'PARSE'\n  // An array of absolute paths for the parser to process, representing all\n  // files matched by the include/exclude globs for this parser.\n  paths: string[]\n  // Config options passed into this parser (not all parsers) from the config.\n  // Each parser's configuration is separate and can take any shape, though we\n  // will recommend using the same naming for common concepts like \"importPaths\".\n  config: Record<string, any>\n  verbose?: boolean\n}\n\nconst FigmaConnectLink = z.object({\n  name: z.string(),\n  url: z.string(),\n})\n\nexport const ParserExecutableMessages = z.array(\n  z.object({\n    // DEBUG and INFO messages should be output to console by the CLI for the\n    // user to read, according to the current log level setting.\n    //\n    // If any WARNING or ERROR messages are returned, the CLI can determine\n    // whether it should proceed with publishing or not based on configuration\n    // and the return code should be zero or non-zero as appropriate.\n    //\n    // There's no need for a \"result\" field as we can infer this from the\n    // messages.\n    level: z.union([z.literal('DEBUG'), z.literal('INFO'), z.literal('WARN'), z.literal('ERROR')]),\n    // Optional type of message which can be displayed highlighted in the output\n    type: z.string().optional(),\n    message: z.string(),\n    // Optional source location which can be displayed in a standardised form\n    sourceLocation: z\n      .object({\n        file: z.string(),\n        line: z.number().optional(),\n      })\n      .optional(),\n  }),\n)\n\n// Zod type modelling the response from a Code Connect parser. Zod allows us to\n// easily validate the response.\n//\n// This type somewhat duplicates the `CodeConnectJSON` type from\n// `figma_connect.ts`, but as Zod doesn't allow us to fully express recursive\n// types such as Intrinsic, we keep this explicit type as well. The `satisfies`\n// should ensure the two types stay in sync.\nexport const ParseResponsePayload = z.object({\n  // Array of Code Connect docs parsed from the input files\n  docs: z.array(\n    z.object({\n      // The Figma node URL the doc links to\n      figmaNode: z.string(),\n      // Optional component name. This is only used for display purposes\n      // so can be omitted if it's not relevant to the language/framework\n      component: z.string().optional(),\n      // Variant restrictions keyed by Figma property name e.g. `{ 'With icon': true }`\n      variant: z.record(z.any()).optional(),\n      // Optional source path/URL, which can either be a path on disk, which\n      // we'll show as a SCM link, or a URL (e.g. for a Storybook parser which\n      // wants to link to the story in Storybook rather than the file in Github)\n      source: z.string().optional(),\n      // Optional source location containing line number information.\n      sourceLocation: z\n        .object({\n          // Optional line number to link to. This is only used if type === 'PATH',\n          // to generate a link to the correct line\n          line: z.number(),\n        })\n        .optional(),\n      // INTERNAL ONLY: Path to the Code Connect file itself, used for parserless migration\n      // Should be stripped out before publishing\n      _codeConnectFilePath: z.string().optional(),\n      // The JS template function to use for this doc\n      template: z.string(),\n      templateData: z.object({\n        // Map of information describing the props used by the template. This is\n        // used by the CLI to validate props before publishing.\n        //\n        // TODO this Zod type is a bit loose - couldn't work out how to model it exactly\n        //\n        // TODO We could look to extract this from the template somehow instead,\n        // (e.g. run it with figma.properties.* stubbed to record accesses) to\n        // avoid needing this duplication.\n        props: z.record(z.object({ kind: z.string(), args: z.any() }) as any),\n        // Optional array of imports for this component. These are prepended\n        // to the example code, but it's useful to keep them separate e.g. if\n        // we ever want to auto-insert imports in VS Code. If more control\n        // over imports is required, they can be output directly by the template\n        // function. Currently they'd have to be output in the code directly, but\n        // the original spec does propose templates being able to return import\n        // sections separately (not implemented as there's no UI for this)\n        //\n        // Right now, there's no way to handle gathering imports from children and\n        // post-processing them (e.g. combining multiple imports from the same file\n        // into a single import). We could consider some way for templates to do this\n        // in future.\n        imports: z.array(z.string()).optional(),\n        // Whether the example should be rendered inline if it's a nested instance\n        nestable: z.boolean().optional(),\n      }),\n      // The language to use for syntax highlighting\n      language: z.nativeEnum(SyntaxHighlightLanguage),\n      // Label to be used for the example in the UI\n      label: z.string(),\n      // Optional array of links to be displayed in the UI.\n      // TODO Not implemented in UI yet\n      links: z.array(FigmaConnectLink).optional(),\n    }) satisfies z.ZodType<BaseCodeConnectObject>,\n  ),\n  // Any info, warning or error messages generated during parsing.\n  messages: ParserExecutableMessages,\n})\n\nexport type PropMapping = Record<string, Intrinsic>\n\nexport type ComponentPropertyDefinition = {\n  // The property type\n  type: 'BOOLEAN' | 'INSTANCE_SWAP' | 'TEXT' | 'VARIANT'\n  // The default value of this property\n  defaultValue: boolean | string\n  // All possible values for this property. Only exists on VARIANT properties\n  variantOptions?: string[]\n}\n\nexport interface FigmaConnectionComponent {\n  // The URL of the Figma component. This field is not in the REST API but\n  // is added for convenience.\n  figmaNodeUrl: string\n  // The ID of the Figma component\n  id: string\n  // The name of the Figma component\n  name: string\n  // The type of the Figma component\n  type: 'COMPONENT' | 'COMPONENT_SET'\n  // Map of the Figma component's properties, keyed by property name\n  componentPropertyDefinitions: Record<string, ComponentPropertyDefinition>\n}\nexport interface FigmaConnection {\n  // The export to use from sourceFilepath\n  sourceExport?: string\n  // A mapping of how Figma props should map to code properties\n  propMapping?: PropMapping\n  // The type signature for the component (React only)\n  reactTypeSignature?: ComponentTypeSignature\n  // Information about the Figma component. This matches the REST API (except the\n  // figmaNodeUrl and normalizedName fields), which should make it easier to\n  // implement and maintain as we can just pass it through\n  component: FigmaConnectionComponent\n}\n\nexport type CreateRequestPayload = {\n  mode: 'CREATE'\n  // Absolute destination directory for the created file. The parser is free to\n  // write to a different directory if appropriate (e.g. it analyses your codebase\n  // to identify where this component should go), but usually it should respect this.\n  destinationDir: string\n  // Optional destination file name. If omitted, the parser can determine the\n  // file name itself.\n  destinationFile?: string\n  // The filepath of the code to be connected. If present, this is used instead of\n  // component.normalizedName\n  sourceFilepath?: string\n  // The export to use from sourceFilepath (TypeScript only)\n  sourceExport?: string\n  // A mapping of how Figma props should map to code properties\n  propMapping?: PropMapping\n  // The type signature for the component (React only)\n  reactTypeSignature?: ComponentTypeSignature\n  // Information about the Figma component. This matches the REST API (except the\n  // figmaNodeUrl and normalizedName fields), which should make it easier to\n  // implement and maintain as we can just pass it through\n  component: {\n    // The URL of the Figma component. This field is not in the REST API but\n    // is added for convenience.\n    figmaNodeUrl: string\n    // The ID of the Figma component\n    id: string\n    // The name of the Figma component\n    name: string\n    // The name of the Figma component, nomalized for use in code.\n    // This field is not in the REST API but is added for convenience.\n    normalizedName: string\n    // The type of the Figma component\n    type: 'COMPONENT' | 'COMPONENT_SET'\n    // Map of the Figma component's properties, keyed by property name\n    componentPropertyDefinitions: Record<string, ComponentPropertyDefinition>\n  }\n  // The configuration object for this parser.\n  // Each parser's configuration is separate and can take any shape, though we\n  // will recommend using the same naming for common concepts like \"importPaths\".\n  config: Record<string, any>\n  verbose?: boolean\n}\n\nexport type CreateRequestPayloadMulti = {\n  mode: 'CREATE'\n  // Absolute destination directory for the created file. The parser is free to\n  // write to a different directory if appropriate (e.g. it analyses your codebase\n  // to identify where this component should go), but usually it should respect this.\n  destinationDir: string\n  // Optional destination file name. If omitted, the parser can determine the\n  // file name itself.\n  destinationFile?: string\n  // The filepath of the code to be connected. If present, this is used instead of\n  // component.normalizedName\n  sourceFilepath?: string\n  // The name of the Figma component, nomalized for use in code.\n  // This field is not in the REST API but is added for convenience.\n  normalizedName: string\n  // The list of design-matchings this file holds\n  // there can be multiple exports per file, each matching to a different design\n  figmaConnections: FigmaConnection[]\n  // The configuration object for this parser.\n  // Each parser's configuration is separate and can take any shape, though we\n  // will recommend using the same naming for common concepts like \"importPaths\".\n  config: Record<string, any>\n}\n\nexport const CreateResponsePayload = z.object({\n  // A list of files created, which can be output to the console\n  createdFiles: z.array(\n    z.object({\n      // The absolute path of the created file\n      filePath: z.string(),\n    }),\n  ),\n  // Any info, warning or error messages generated during creation.\n  messages: ParserExecutableMessages,\n})\n\nexport type ParserRequestPayload = ParseRequestPayload | CreateRequestPayload\n"]}