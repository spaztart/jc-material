{"version":3,"file":"parser_common.js","sourceRoot":"","sources":["../../src/connect/parser_common.ts"],"names":[],"mappings":"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","sourcesContent":["import ts, { JsxExpression } from 'typescript'\nimport { FIGMA_CONNECT_CALL, PropMappings, valueToString } from './intrinsics'\nimport { highlight, reset } from '../common/logging'\nimport { error } from 'console'\nimport {\n  assertIsObjectLiteralExpression,\n  assertIsStringLiteral,\n  convertObjectLiteralToJs,\n  parsePropertyOfType,\n  stripQuotesFromNode,\n} from '../typescript/compiler'\nimport { BaseCodeConnectConfig } from './project'\nimport { CodeConnectJSON } from './figma_connect'\n\ninterface ParserErrorContext {\n  sourceFile: ts.SourceFile\n  node: ts.Node | undefined\n}\n\nexport function getPositionInSourceFile(node: ts.Node, sourceFile: ts.SourceFile) {\n  return sourceFile.getLineAndCharacterOfPosition(node.getStart(sourceFile))\n}\n\nexport class ParserError extends Error {\n  sourceFilePosition: ts.LineAndCharacter | null\n  sourceFileName: string\n\n  constructor(message: string, context?: ParserErrorContext) {\n    super(message)\n    this.name = 'ParserError'\n    this.sourceFileName = context?.sourceFile.fileName || ''\n    this.sourceFilePosition =\n      context && context.node\n        ? getPositionInSourceFile(context.node, context.sourceFile) || null\n        : null\n  }\n\n  toString() {\n    let msg = `${highlight(error(this.name))}: ${this.message}\\n`\n    if (this.sourceFileName && this.sourceFilePosition) {\n      msg += ` -> ${reset(this.sourceFileName)}:${this.sourceFilePosition.line}:${\n        this.sourceFilePosition.character\n      }\\n`\n    }\n    return msg\n  }\n\n  toDebugString() {\n    return this.toString() + `\\n ${this.stack}`\n  }\n}\n\nexport class InternalError extends ParserError {\n  constructor(message: string) {\n    super(message)\n    this.name = 'InternalError'\n  }\n}\n\nexport interface ParserContext {\n  checker: ts.TypeChecker\n  sourceFile: ts.SourceFile\n  resolvedImports: Record<string, string>\n  config: any\n  absPath: string\n}\n\n/**\n * Factory to create a function that is used to create `__PROP__(propName)`\n * function nodes, which are used to replace prop references and ultimately\n * replaced.\n *\n * @returns Function to create `__PROP__(propName)` function nodes\n */\nexport function makeCreatePropPlaceholder({\n  propMappings,\n  referencedProps,\n  sourceFile,\n}: {\n  /** The prop mappings object */\n  propMappings?: PropMappings | undefined\n  /** The set of referenced props in the current example */\n  referencedProps: Set<string>\n  /** The source file */\n  sourceFile: ts.SourceFile\n}) {\n  return function ({\n    name,\n    node,\n    wrapInJsxExpression = false,\n  }: {\n    /** The prop name */\n    name: string\n    /** The props node, used for error reporting */\n    node: ts.Node\n    /** Whether to wrap the placeholder in a JSX expression node */\n    wrapInJsxExpression?: boolean\n  }) {\n    let propReferenceName = name\n    // for nested prop references like `nested.prop`, we only want to look for\n    // the prop mapping of `nested`, but include the full `nested.prop` in the\n    // __PROP__ call\n    if (name.includes('.')) {\n      propReferenceName = name.split('.')[0]\n    }\n\n    // if prop mappings exist, check that the prop reference is in the mappings\n    if (propMappings) {\n      const mappedProp = propMappings[propReferenceName]\n      if (!mappedProp) {\n        throw new ParserError(\n          `Could not find prop mapping for ${propReferenceName} in the props object`,\n          {\n            sourceFile,\n            node,\n          },\n        )\n      }\n    }\n\n    referencedProps.add(propReferenceName)\n    const callExpression = ts.factory.createCallExpression(\n      ts.factory.createIdentifier('__PROP__'),\n      undefined,\n      [ts.factory.createStringLiteral(name)],\n    )\n\n    if (wrapInJsxExpression) {\n      return ts.factory.createJsxExpression(undefined, callExpression)\n    } else {\n      return callExpression\n    }\n  }\n}\n\n/**\n * TS AST visitor function for use with example functions, which replaces\n * references to the `props` argument in various forms in the example code with\n * `__PROP__(propName)` placeholders (created with a createPropPlaceholder\n * function).\n *\n * This is called when transforming the TS AST, and allows us to normalise the\n * different forms of supported prop references into a single representation,\n * which we can then handle consistently (currently we replace the placeholders,\n * using a regex).\n *\n * @returns Placeholder node, or undefined if the node is not a supported prop\n * reference (which results in no transformation)\n */\nexport function visitPropReferencingNode({\n  propsParameter,\n  node,\n  createPropPlaceholder,\n  useJsx,\n}: {\n  /** The props function parameter node */\n  propsParameter: ts.ParameterDeclaration\n  /** The node to visit */\n  node: ts.Node\n  /**\n   * The function to create `__PROP__(propName)` function nodes, created by\n   * `baseCreatePropPlaceholder`\n   * */\n  createPropPlaceholder: ReturnType<typeof makeCreatePropPlaceholder>\n  /** Whether to support JSX syntax or not */\n  useJsx?: boolean\n}): ts.Expression | undefined {\n  // `props.` notation\n  if (\n    ts.isIdentifier(propsParameter.name) &&\n    ts.isPropertyAccessExpression(node) &&\n    node.expression.getText().startsWith(propsParameter.name.getText())\n  ) {\n    // nested notation e.g `props.nested.prop`\n    if (ts.isPropertyAccessExpression(node.expression)) {\n      let current: ts.Node = node\n      const parts: string[] = []\n\n      // Build the property name by traversing up the chain\n      while (ts.isPropertyAccessExpression(current)) {\n        parts.unshift(current.name.getText())\n        current = current.expression\n      }\n\n      // Join the parts together to form the full property name\n      const name = parts.join('.')\n      return createPropPlaceholder({ name, node })\n    }\n    const name = node.name.getText()\n    return createPropPlaceholder({ name, node })\n  }\n  // `props[\"\"]` notation\n  if (\n    ts.isIdentifier(propsParameter.name) &&\n    ts.isElementAccessExpression(node) &&\n    node.expression.getText().startsWith(propsParameter.name.getText()) &&\n    ts.isStringLiteral(node.argumentExpression)\n  ) {\n    const name = stripQuotesFromNode(node.argumentExpression)\n    return createPropPlaceholder({ name, node })\n  }\n  // object destructuring references\n  if (ts.isObjectBindingPattern(propsParameter.name)) {\n    const isValidNode = useJsx\n      ? ts.isJsxExpression(node)\n      : ts.isPropertyAccessExpression(node) || ts.isIdentifier(node)\n    const target = useJsx ? (node as JsxExpression).expression : node\n\n    if (\n      isValidNode &&\n      target &&\n      propsParameter.name.elements.find((el) => target?.getText().startsWith(el.name.getText()))\n    ) {\n      const name = target.getText()\n      return createPropPlaceholder({ name, node, wrapInJsxExpression: useJsx })\n    }\n  }\n\n  return undefined\n}\n\n/**\n * Get template code to create variables referencing the props in the prop\n * mappings. This converts the prop mappings into JS calls like `const propName\n * = figma.properties.string('Prop Name')`, which can then be prepended to the\n * template code.\n *\n * @returns Template code string\n */\nexport function getReferencedPropsForTemplate({\n  propMappings = {},\n}: {\n  /** The prop mappings object */\n  propMappings: PropMappings | undefined\n  /** The top level node, used for error reporting */\n  exp: ts.Node\n  /** The source file */\n  sourceFile: ts.SourceFile\n}) {\n  let templateCode = ''\n\n  if (Object.keys(propMappings).length > 0) {\n    for (const prop in propMappings) {\n      const propMapping = propMappings[prop]\n      templateCode += `const ${prop} = ${valueToString(propMapping)}\\n`\n    }\n    templateCode += `const __props = {}\\n`\n    Object.keys(propMappings).forEach((prop) => {\n      // If trying to render prop resulted in an error (e.g. layer was not found\n      // because it was invisible), don't include it in the __props object as\n      // this will result in a runtime error.\n      //\n      // TODO Note that this can also happen if there is a typo in the prop name\n      // of a nested prop, because we don't validate these at publish time,\n      // which would be confusing. Perhaps we should have a way to show a\n      // warning but not an error to the user.\n      templateCode += `if (${prop} && ${prop}.type !== 'ERROR') {\n  __props[\"${prop}\"] = ${prop}\n}\\n`\n    })\n    templateCode += `\\n`\n  }\n\n  return templateCode\n}\n\n/**\n * Checks if a file contains Code Connect by looking for the `figma.connect()` function call\n */\nexport function isFigmaConnectFile(\n  program: ts.Program,\n  file: string,\n  extension: string | string[],\n) {\n  const allowedExtensions = Array.isArray(extension) ? extension : [extension]\n  const fileExtension = file.split('.').pop()\n\n  // If the file has no extension, we can't determine if it's a Code Connect file\n  if (!fileExtension) {\n    return false\n  }\n\n  // If the file extension is not in the list of supported extensions, it's not a Code Connect file\n  if (!allowedExtensions.includes(fileExtension)) {\n    return false\n  }\n\n  const sourceFile = program.getSourceFile(file)\n  if (!sourceFile) {\n    throw new InternalError(`Could not find source file for ${file}`)\n  }\n\n  return (\n    findDescendants(sourceFile, (node: ts.Node) => {\n      if (isFigmaConnectCall(node, sourceFile)) {\n        return true\n      }\n      return false\n    }).length > 0\n  )\n}\n\n/**\n * Checks if an AST node is a `figma.connect()` call\n *\n * @param node AST node\n * @param sourceFile Source file\n * @returns True if the node is a `figma.connect()` call\n */\nexport function isFigmaConnectCall(\n  node: ts.Node,\n  sourceFile: ts.SourceFile,\n): node is ts.CallExpression {\n  return (\n    ts.isCallExpression(node) && node.expression.getText(sourceFile).includes(FIGMA_CONNECT_CALL)\n  )\n}\n\nexport function findDescendants(node: ts.Node, cb: (node: ts.Node) => boolean): ts.Node[] {\n  const matches: ts.Node[] = []\n  function visit(node: ts.Node) {\n    if (cb(node)) {\n      matches.push(node)\n    }\n    ts.forEachChild(node, visit)\n  }\n  visit(node)\n  return matches\n}\n\n/**\n * Parses the `links` field of a `figma.connect()` call\n *\n * @param linksArray an ArrayLiteralExpression\n * @param parserContext Parser context\n * @returns An array of link objects\n */\nexport function parseLinks(linksArray: ts.ArrayLiteralExpression, parserContext: ParserContext) {\n  const { sourceFile } = parserContext\n  const links: { name: string; url: string }[] = []\n  for (const element of linksArray.elements) {\n    assertIsObjectLiteralExpression(\n      element,\n      sourceFile,\n      `'links' must be an array literal with objects of the format { name: string, url: string }`,\n    )\n    const name = parsePropertyOfType({\n      objectLiteralNode: element,\n      propertyName: 'name',\n      predicate: ts.isStringLiteral,\n      parserContext,\n      required: true,\n      errorMessage: \"The 'name' property must be a string literal\",\n    })\n    const url = parsePropertyOfType({\n      objectLiteralNode: element,\n      propertyName: 'url',\n      predicate: ts.isStringLiteral,\n      parserContext,\n      required: true,\n      errorMessage: \"The 'url' property must be a string literal\",\n    })\n\n    if (name && url) {\n      links.push({ name: stripQuotesFromNode(name), url: stripQuotesFromNode(url) })\n    }\n  }\n\n  return links\n}\n\nexport function parseVariant(\n  variantMap: ts.ObjectLiteralExpression,\n  sourceFile: ts.SourceFile,\n  checker: ts.TypeChecker,\n) {\n  return convertObjectLiteralToJs(variantMap, sourceFile, checker, (valueNode) => {\n    if (\n      !ts.isObjectLiteralElement(valueNode) &&\n      !ts.isStringLiteral(valueNode) &&\n      !ts.isNumericLiteral(valueNode) &&\n      valueNode.kind !== ts.SyntaxKind.TrueKeyword &&\n      valueNode.kind !== ts.SyntaxKind.FalseKeyword\n    ) {\n      throw new ParserError(`Invalid value for variant, got: ${valueNode.getText()}`, {\n        node: valueNode,\n        sourceFile,\n      })\n    }\n  })\n}\n\n/**\n * Parses the `imports` field of a `figma.connect()` call\n *\n * @param importsArray an ArrayLiteralExpression\n * @param parserContext Parser context\n * @returns An array of link objects\n */\nexport function parseImports(\n  importsArray: ts.ArrayLiteralExpression,\n  parserContext: ParserContext,\n) {\n  const { sourceFile } = parserContext\n  const imports: string[] = []\n  for (const element of importsArray.elements) {\n    assertIsStringLiteral(element, sourceFile, `'imports' must be an array literal with strings`)\n    imports.push(stripQuotesFromNode(element))\n  }\n\n  return imports\n}\n\nexport type ParseOptions = {\n  repoUrl?: string\n  debug?: boolean\n  silent?: boolean\n  skipTemplateHelpers?: boolean\n}\n\nexport type ParseFn = (\n  node: ts.CallExpression,\n  parserContext: ParserContext,\n  { repoUrl, silent }: ParseOptions,\n) => Promise<CodeConnectJSON>\n\nexport type ResolveImportsFn = (\n  program: ts.Program,\n  sourceFile: ts.SourceFile,\n) => Record<string, string>\n\nexport async function parseCodeConnect<T extends BaseCodeConnectConfig>({\n  program,\n  file,\n  config,\n  absPath,\n  parseFn,\n  resolveImportsFn,\n  parseOptions = {},\n}: {\n  program: ts.Program\n  file: string\n  config: T\n  absPath: string\n  parseFn: ParseFn\n  resolveImportsFn?: ResolveImportsFn\n  parseOptions?: ParseOptions\n}): Promise<any[]> {\n  const sourceFile = program.getSourceFile(file)\n  if (!sourceFile) {\n    throw new InternalError(`Could not find source file for ${file}`)\n  }\n\n  const parserContext = {\n    checker: program.getTypeChecker(),\n    sourceFile,\n    resolvedImports: resolveImportsFn ? resolveImportsFn(program, sourceFile) : {},\n    config,\n    absPath,\n  }\n  const codeConnectObjects: CodeConnectJSON[] = []\n\n  const nodes: ts.Node[] = [parserContext.sourceFile]\n  while (nodes.length > 0) {\n    const node = nodes.shift()!\n    if (isFigmaConnectCall(node, parserContext.sourceFile)) {\n      const doc = await parseFn(node, parserContext, parseOptions)\n      if (doc) {\n        doc._codeConnectFilePath = file\n        codeConnectObjects.push(doc)\n      }\n    }\n    nodes.push(...node.getChildren(parserContext.sourceFile))\n  }\n\n  if (codeConnectObjects.length === 0) {\n    throw new ParserError(`Didn't find any calls to figma.connect()`, {\n      sourceFile: parserContext.sourceFile,\n      node: parserContext.sourceFile,\n    })\n  }\n\n  return codeConnectObjects\n}\n"]}