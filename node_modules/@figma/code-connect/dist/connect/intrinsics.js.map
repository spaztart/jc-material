{"version":3,"file":"intrinsics.js","sourceRoot":"","sources":["../../src/connect/intrinsics.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript'\nimport { InternalError, ParserContext, ParserError } from './parser_common'\nimport {\n  assertIsArrayLiteralExpression,\n  assertIsStringLiteral,\n  convertArrayLiteralToJs,\n  isUndefinedType,\n  stripQuotesFromNode,\n} from '../typescript/compiler'\nimport { convertObjectLiteralToJs } from '../typescript/compiler'\nimport { assertIsObjectLiteralExpression } from '../typescript/compiler'\nimport { FigmaConnectAPI } from './api'\nimport {\n  FCCValue,\n  _fcc_array,\n  _fcc_function,\n  _fcc_identifier,\n  _fcc_jsxElement,\n  _fcc_object,\n  _fcc_templateString,\n} from '../react/parser_template_helpers'\nimport htmlApi from '../html/index_html'\nimport reactApi from '../react/index_react'\nimport { Modifier, modifierToString, parseModifier } from './modifiers'\n\nexport const API_PREFIX = 'figma'\nexport const FIGMA_CONNECT_CALL = `${API_PREFIX}.connect`\n\nexport enum IntrinsicKind {\n  Enum = 'enum',\n  String = 'string',\n  Boolean = 'boolean',\n  Instance = 'instance',\n  Children = 'children',\n  NestedProps = 'nested-props',\n  ClassName = 'className',\n  TextContent = 'text-content',\n  Slot = 'slot',\n}\n\nexport interface IntrinsicBase {\n  kind: IntrinsicKind\n  args: {}\n  modifiers?: Modifier[]\n}\n\nexport type ValueMappingKind = FCCValue | Intrinsic\n\nexport interface FigmaBoolean extends IntrinsicBase {\n  kind: IntrinsicKind.Boolean\n  args: {\n    figmaPropName: string\n    valueMapping?: Record<'true' | 'false', ValueMappingKind>\n  }\n}\n\nexport type ValueMapping = Record<string, ValueMappingKind>\n\nexport interface FigmaEnum extends IntrinsicBase {\n  kind: IntrinsicKind.Enum\n  args: {\n    figmaPropName: string\n    valueMapping: ValueMapping\n  }\n}\n\nexport interface FigmaString extends IntrinsicBase {\n  kind: IntrinsicKind.String\n  args: {\n    figmaPropName: string\n  }\n}\n\nexport interface FigmaInstance extends IntrinsicBase {\n  kind: IntrinsicKind.Instance\n  args: {\n    figmaPropName: string\n  }\n}\n\nexport interface FigmaChildren extends IntrinsicBase {\n  kind: IntrinsicKind.Children\n  args: {\n    layers: string[]\n  }\n}\n\nexport interface FigmaNestedProps extends IntrinsicBase {\n  kind: IntrinsicKind.NestedProps\n  args: {\n    layer: string\n    props: Record<string, Intrinsic>\n  }\n}\n\nexport interface FigmaClassName extends IntrinsicBase {\n  kind: IntrinsicKind.ClassName\n  args: {\n    className: (string | Intrinsic)[]\n  }\n}\n\nexport interface FigmaTextContent extends IntrinsicBase {\n  kind: IntrinsicKind.TextContent\n  args: {\n    layer: string\n  }\n}\n\nexport interface FigmaSlot extends IntrinsicBase {\n  kind: IntrinsicKind.Slot\n  args: {\n    figmaPropName: string\n  }\n}\n\nexport type Intrinsic =\n  | FigmaBoolean\n  | FigmaEnum\n  | FigmaString\n  | FigmaInstance\n  | FigmaSlot\n  | FigmaChildren\n  | FigmaNestedProps\n  | FigmaClassName\n  | FigmaTextContent\n\nconst Intrinsics: {\n  [key: string]: {\n    match: (exp: ts.CallExpression) => exp is ts.CallExpression\n    parse: (exp: ts.CallExpression, parser: ParserContext) => Intrinsic\n  }\n} = {}\n\n/**\n * These functions are used to convert \"intrinsic\" parser types (which are calls to helper functions\n * like `Figma.boolean() in code)` to an object representing that intrinsic that we can serialize to JSON.\n *\n * Each call to `makeIntrinsic` should take a function from the {@link FigmaConnectAPI},\n * ensuring that the name of the intrinsic that we're parsing matches the name of the function\n *\n * @param staticFunctionMember\n * @param obj\n */\nfunction makeIntrinsic<K extends keyof typeof htmlApi | typeof reactApi>(\n  intrinsicName: K,\n  obj: (name: string) => any,\n) {\n  const name = `${API_PREFIX}.${intrinsicName}`\n  Intrinsics[name] = {\n    match: (exp: ts.CallExpression) => {\n      return ts.isCallExpression(exp) && exp.getText().replace(/\\s/g, '').startsWith(name)\n    },\n    ...obj(name),\n  }\n}\n\nmakeIntrinsic('boolean', (name) => {\n  return {\n    parse: (exp: ts.CallExpression, ctx: ParserContext): FigmaBoolean => {\n      const figmaPropNameIdentifier = exp.arguments?.[0]\n      assertIsStringLiteral(\n        figmaPropNameIdentifier,\n        ctx.sourceFile,\n        `${name} takes at least one argument, which is the Figma property name`,\n      )\n      const valueMappingArg = exp.arguments?.[1]\n      let valueMapping\n      if (valueMappingArg) {\n        assertIsObjectLiteralExpression(\n          valueMappingArg,\n          ctx.sourceFile,\n          `${name} second argument should be an object literal, that sets values for 'true' and 'false'`,\n        )\n        valueMapping = parsePropsObject(valueMappingArg, ctx) as Record<\n          'true' | 'false',\n          ValueMappingKind\n        >\n      }\n      return {\n        kind: IntrinsicKind.Boolean,\n        args: {\n          figmaPropName: stripQuotesFromNode(figmaPropNameIdentifier),\n          valueMapping,\n        },\n      }\n    },\n  }\n})\n\nmakeIntrinsic('enum', (name) => {\n  return {\n    parse: (exp: ts.CallExpression, ctx: ParserContext): FigmaEnum => {\n      const { sourceFile } = ctx\n      const figmaPropNameIdentifier = exp.arguments?.[0]\n      assertIsStringLiteral(\n        figmaPropNameIdentifier,\n        sourceFile,\n        `${name} takes at least one argument, which is the Figma property name`,\n      )\n      const valueMapping = exp.arguments?.[1]\n      assertIsObjectLiteralExpression(\n        valueMapping,\n        sourceFile,\n        `${name} second argument should be an object literal, that maps Figma prop values to code`,\n      )\n      return {\n        kind: IntrinsicKind.Enum,\n        args: {\n          figmaPropName: stripQuotesFromNode(figmaPropNameIdentifier),\n          valueMapping: parsePropsObject(valueMapping, ctx),\n        },\n      }\n    },\n  }\n})\n\nmakeIntrinsic('string', (name) => {\n  return {\n    parse: (exp: ts.CallExpression, ctx: ParserContext): FigmaString => {\n      const { sourceFile } = ctx\n      const figmaPropNameIdentifier = exp.arguments?.[0]\n      assertIsStringLiteral(\n        figmaPropNameIdentifier,\n        sourceFile,\n        `${name} takes at least one argument, which is the Figma property name`,\n      )\n      return {\n        kind: IntrinsicKind.String,\n        args: {\n          figmaPropName: stripQuotesFromNode(figmaPropNameIdentifier),\n        },\n      }\n    },\n  }\n})\n\nmakeIntrinsic('instance', (name) => {\n  return {\n    parse: (exp: ts.CallExpression, ctx: ParserContext): FigmaInstance => {\n      const { sourceFile } = ctx\n      const figmaPropNameIdentifier = exp.arguments?.[0]\n\n      assertIsStringLiteral(\n        figmaPropNameIdentifier,\n        sourceFile,\n        `${name} takes at least one argument, which is the Figma property name`,\n      )\n\n      return {\n        kind: IntrinsicKind.Instance,\n        args: {\n          figmaPropName: stripQuotesFromNode(figmaPropNameIdentifier),\n        },\n      }\n    },\n  }\n})\n\nmakeIntrinsic('slot', (name) => {\n  return {\n    parse: (exp: ts.CallExpression, ctx: ParserContext): FigmaSlot => {\n      const { sourceFile } = ctx\n      const figmaPropNameIdentifier = exp.arguments?.[0]\n\n      assertIsStringLiteral(\n        figmaPropNameIdentifier,\n        sourceFile,\n        `${name} takes a single argument which is the Figma property name`,\n      )\n\n      return {\n        kind: IntrinsicKind.Slot,\n        args: {\n          figmaPropName: stripQuotesFromNode(figmaPropNameIdentifier),\n        },\n      }\n    },\n  }\n})\n\nmakeIntrinsic('children', (name) => {\n  return {\n    parse: (exp: ts.CallExpression, ctx: ParserContext): FigmaChildren => {\n      const { sourceFile } = ctx\n      const layerName = exp.arguments?.[0]\n      const layers: string[] = []\n      if (ts.isStringLiteral(layerName)) {\n        layers.push(stripQuotesFromNode(layerName))\n      } else if (ts.isArrayLiteralExpression(layerName) && layerName.elements.length > 0) {\n        layerName.elements.forEach((el) => {\n          assertIsStringLiteral(el, sourceFile)\n          const name = stripQuotesFromNode(el)\n          if (name.includes('*')) {\n            throw new ParserError(\n              `Wildcards can not be used with an array of strings. Use a single string literal instead.`,\n              {\n                node: layerName,\n                sourceFile,\n              },\n            )\n          }\n          layers.push(stripQuotesFromNode(el))\n        })\n      } else {\n        throw new ParserError(\n          `Invalid argument to ${name}, should be a string literal or an array of strings`,\n          {\n            node: layerName,\n            sourceFile,\n          },\n        )\n      }\n\n      return {\n        kind: IntrinsicKind.Children,\n        args: {\n          layers,\n        },\n      }\n    },\n  }\n})\n\nmakeIntrinsic('nestedProps', (name) => {\n  return {\n    parse: (exp: ts.CallExpression, ctx: ParserContext): FigmaNestedProps => {\n      const { sourceFile } = ctx\n      const layerName = exp.arguments?.[0]\n      const mapping = exp.arguments?.[1]\n\n      assertIsStringLiteral(\n        layerName,\n        sourceFile,\n        `Invalid argument to ${name}, \\`layerName\\` should be a string literal`,\n      )\n      assertIsObjectLiteralExpression(\n        mapping,\n        sourceFile,\n        `Invalid argument to ${name}, \\`props\\` should be an object literal`,\n      )\n\n      ts.forEachChild(mapping, (node) => {\n        if (\n          ts.isPropertyAssignment(node) &&\n          ts.isCallExpression(node.initializer) &&\n          node.initializer.getText().startsWith('figma.nestedProps')\n        ) {\n          throw new ParserError(\n            `nestedProps can not be nested inside another nestedProps call, instead, pass the deeply nested layer name at the top level`,\n          )\n        }\n      })\n\n      return {\n        kind: IntrinsicKind.NestedProps,\n        args: {\n          layer: stripQuotesFromNode(layerName),\n          props: parsePropsObject(mapping, ctx),\n        },\n      }\n    },\n  }\n})\n\nmakeIntrinsic('className', (name) => {\n  return {\n    parse: (exp: ts.CallExpression, ctx: ParserContext): FigmaClassName => {\n      const { sourceFile } = ctx\n      const classNameArg = exp.arguments?.[0]\n      const className: (string | Intrinsic)[] = []\n      assertIsArrayLiteralExpression(classNameArg, sourceFile, `${name} takes an array of strings`)\n\n      classNameArg.elements.forEach((el) => {\n        if (ts.isStringLiteral(el)) {\n          className.push(stripQuotesFromNode(el))\n        } else if (ts.isCallExpression(el)) {\n          className.push(parseIntrinsic(el, ctx))\n        }\n      })\n\n      return {\n        kind: IntrinsicKind.ClassName,\n        args: {\n          className,\n        },\n      }\n    },\n  }\n})\n\nmakeIntrinsic('textContent', (name) => {\n  return {\n    parse: (exp: ts.CallExpression, ctx: ParserContext): FigmaTextContent => {\n      const { sourceFile } = ctx\n      const layerNameArg = exp.arguments?.[0]\n      assertIsStringLiteral(\n        layerNameArg,\n        sourceFile,\n        `${name} takes a single argument which is the Figma layer name`,\n      )\n\n      return {\n        kind: IntrinsicKind.TextContent,\n        args: {\n          layer: stripQuotesFromNode(layerNameArg),\n        },\n      }\n    },\n  }\n})\n\n/**\n * Parses a call expression to an intrinsic\n *\n * @param exp Expression to parse\n * @param parserContext parser context\n * @returns\n */\nexport function parseIntrinsic(exp: ts.CallExpression, parserContext: ParserContext): Intrinsic {\n  for (const key in Intrinsics) {\n    if (Intrinsics[key].match(exp)) {\n      // Chained call expressions in TS are nested with the innermost call expression\n      // being the first in the chain. We need to reverse the chain so that the intrinsic\n      // is the first element in the array. The TS AST looks like this for a().b():\n      // CallExpression [a().b()] ->\n      //   PropertyAccessExpression [a().b] ->\n      //     CallExpression [a()]\n\n      let callChain = []\n      let current: any = exp\n      while (current) {\n        if (ts.isCallExpression(current)) {\n          callChain.push(current)\n          current = current.expression\n        } else if (ts.isPropertyAccessExpression(current)) {\n          current = current.expression\n        } else {\n          current = null\n        }\n      }\n\n      // If there's only one call expression just return the matching intrinsic\n      callChain = callChain.reverse()\n      if (callChain.length <= 1) {\n        return Intrinsics[key].parse(exp, parserContext)\n      }\n\n      // The first call expression is the intrinsic itself, and any following call\n      // expressions are modifiers\n      const intrinsic = Intrinsics[key].parse(callChain.shift()!, parserContext)\n      const modifiers = callChain.map((modifier) => parseModifier(modifier, parserContext))\n\n      return {\n        ...intrinsic,\n        modifiers,\n      }\n    }\n  }\n\n  throw new ParserError(`Unknown intrinsic: ${exp.getText()}`, {\n    node: exp,\n    sourceFile: parserContext.sourceFile,\n  })\n}\n\n/**\n * Replace newlines in enum values with \\\\n so that we don't output\n * broken JS with newlines inside the string\n */\nfunction replaceNewlines(str: string) {\n  return str.toString().replaceAll('\\n', '\\\\n').replaceAll(\"'\", \"\\\\'\")\n}\n\nexport function valueToString(value: ValueMappingKind, childLayer?: string) {\n  if (typeof value === 'boolean' || typeof value === 'number' || typeof value === 'undefined') {\n    return `${value}`\n  }\n\n  if (typeof value === 'string') {\n    return `'${replaceNewlines(value)}'`\n  }\n\n  if ('kind' in value) {\n    // Mappings can be nested, e.g. an enum value can be figma.instance(...)\n    return `${intrinsicToString(value as Intrinsic, childLayer)}`\n  }\n\n  // Convert objects to strings\n  const str = typeof value.$value === 'string' ? value.$value : `${JSON.stringify(value.$value)}`\n  const v = replaceNewlines(str)\n\n  switch (value.$type) {\n    case 'function':\n      return `_fcc_function('${v}')`\n    case 'identifier':\n      return `_fcc_identifier('${v}')`\n    case 'object':\n      // Don't pass the object itself wrapped in quotes - this helper needs to instantiate the actual\n      // object, as it may be used in the snippet code\n      return `_fcc_object(${v})`\n    case 'template-string':\n      return `_fcc_templateString('${v}')`\n    case 'jsx-element':\n      return `_fcc_jsxElement('${v}')`\n    case 'array':\n      return `_fcc_array(${v})`\n    default:\n      throw new InternalError(`Unknown helper type: ${value}`)\n  }\n}\n\nexport function valueMappingToString(valueMapping: ValueMapping, childLayer?: string): string {\n  // For enums (and booleans with a valueMapping provided), convert the\n  // value mapping to an object.\n  return (\n    '{\\n' +\n    Object.entries(valueMapping)\n      .map(([key, value]) => {\n        return `\"${key}\": ${valueToString(value, childLayer)}`\n      })\n      .join(',\\n') +\n    '}'\n  )\n}\n\nlet nestedLayerCount = 0\n\nexport function intrinsicToString(\n  { kind, args, modifiers = [] }: Intrinsic,\n  childLayer?: string,\n): string {\n  const selector = childLayer ?? `figma.currentLayer`\n  switch (kind) {\n    case IntrinsicKind.String:\n      return `${selector}.__properties__.string('${args.figmaPropName}')`\n    case IntrinsicKind.Instance: {\n      // Outputs:\n      // `const propName = figma.properties.string('propName')`, or\n      // `const propName = figma.properties.boolean('propName')`, or\n      // `const propName = figma.properties.instance('propName')`\n      if (modifiers.length > 0) {\n        const instance = `${selector}.__properties__.__instance__('${args.figmaPropName}')`\n        let body = `const instance = ${instance}\\n`\n        body += `return instance && instance.type !== \"ERROR\" ? ${['instance', ...modifiers.map(modifierToString)].join('.')} : instance`\n        return `(function () {${body}})()`\n      }\n      return `${selector}.__properties__.instance('${args.figmaPropName}')`\n    }\n    case IntrinsicKind.Boolean: {\n      if (args.valueMapping) {\n        const mappingString = valueMappingToString(args.valueMapping, childLayer)\n        // Outputs: `const propName = figma.properties.boolean('propName', { ... mapping object from above ... })`\n        return `${selector}.__properties__.boolean('${args.figmaPropName}', ${mappingString})`\n      }\n      return `${selector}.__properties__.boolean('${args.figmaPropName}')`\n    }\n    case IntrinsicKind.Enum: {\n      const mappingString = valueMappingToString(args.valueMapping, childLayer)\n\n      // Outputs: `const propName = figma.properties.enum('propName', { ... mapping object from above ... })`\n      return `${selector}.__properties__.enum('${args.figmaPropName}', ${mappingString})`\n    }\n    case IntrinsicKind.Slot: {\n      return `${selector}.__properties__.slot('${args.figmaPropName}')`\n    }\n    case IntrinsicKind.Children: {\n      // Outputs: `const propName = figma.properties.children([\"Layer 1\", \"Layer 2\"])`\n      return `${selector}.__properties__.children([${args.layers.map((layerName) => `\"${layerName}\"`).join(',')}])`\n    }\n    case IntrinsicKind.ClassName: {\n      // Outputs: `const propName = ['btn-base', figma.currentLayer.__properties__.enum('Size, { Large: 'btn-large' })].join(\" \")`\n      return `[${args.className.map((className) => (typeof className === 'string' ? `\"${className}\"` : `${intrinsicToString(className, childLayer)}`)).join(', ')}].filter(v => !!v).join(' ')`\n    }\n    case IntrinsicKind.TextContent: {\n      return `${selector}.__findChildWithCriteria__({ name: '${args.layer}', type: \"TEXT\" }).__render__()`\n    }\n    case IntrinsicKind.NestedProps: {\n      let body: string = ''\n      // the actual layer name in figma could have a bunch of special characters in it,\n      // and if we try to normalize it to a valid JS identifier, it could conflict with\n      // other variables in the template code. So we generate a unique variable name\n      // for each nested layer reference instead. The only reason it's wrapped in a funciton\n      // currently is to keep the error checking out of global scope\n      const nestedLayerRef = `nestedLayer${nestedLayerCount++}`\n      body += `const ${nestedLayerRef} = figma.currentLayer.__find__(\"${args.layer}\")\\n`\n      body += `return ${nestedLayerRef}.type === \"ERROR\" ? ${nestedLayerRef} : {\n${Object.entries(args.props).map(\n  ([key, intrinsic]) => `${key}: ${intrinsicToString(intrinsic, nestedLayerRef)}\\n`,\n)}\n        }\\n`\n      return `(function () {${body}})()`\n    }\n    default:\n      throw new InternalError(`Unknown intrinsic: ${kind}`)\n  }\n}\n\n/**\n * Converts an expression to an FCC value, which is a wrapper around the actual value that\n * includes the type information. This is used to serialize the value to JSON and then\n * deserialize it back to the correct type in the generated code.\n *\n * @param valueNode\n * @param parserContext\n * @returns\n */\nfunction expressionToFccEnumValue(\n  valueNode: ts.Expression,\n  parserContext: ParserContext,\n): FCCValue {\n  const { sourceFile, checker } = parserContext\n\n  if (ts.isParenthesizedExpression(valueNode)) {\n    return expressionToFccEnumValue(valueNode.expression, parserContext)\n  }\n\n  if (ts.isJsxElement(valueNode) || ts.isJsxSelfClosingElement(valueNode)) {\n    return _fcc_jsxElement(valueNode.getText())\n  }\n\n  if (ts.isArrowFunction(valueNode) || ts.isFunctionExpression(valueNode)) {\n    return _fcc_function(valueNode.getText())\n  }\n\n  if (ts.isObjectLiteralExpression(valueNode)) {\n    // should recursively convert to FCC\n    return _fcc_object(parsePropsObject(valueNode, parserContext))\n  }\n\n  if (ts.isArrayLiteralExpression(valueNode)) {\n    return _fcc_array(\n      convertArrayLiteralToJs(valueNode, sourceFile, checker, (valueNode) => {\n        if (ts.isCallExpression(valueNode)) {\n          return parseIntrinsic(valueNode, parserContext)\n        }\n        return expressionToFccEnumValue(valueNode, parserContext)\n      }),\n    )\n  }\n\n  if (ts.isTemplateLiteral(valueNode)) {\n    const str = valueNode.getText().replaceAll('`', '')\n    return _fcc_templateString(str)\n  }\n\n  // Handles enums, for example `MyEnum.Value`\n  if (ts.isPropertyAccessExpression(valueNode)) {\n    return _fcc_identifier(valueNode.getText())\n  }\n\n  // Any other identifiers (except undefined) are treated as React components, for example `MyComponent`.\n  // We don't support referencing other variables in props object so this should be fine.\n  if (ts.isIdentifier(valueNode) && !isUndefinedType(valueNode, parserContext.checker)) {\n    return _fcc_identifier(valueNode.getText())\n  }\n\n  // Fall back to the default conversion in `convertObjectLiteralToJs`\n  return undefined\n}\n\n/**\n * Parses the `props` field in a `figma.connect()` call, returning a mapping of\n * prop names to their respective intrinsic types\n *\n * @param objectLiteral An object literal expression\n * @param parserContext Parser context\n * @returns\n */\nexport function parsePropsObject(\n  objectLiteral: ts.ObjectLiteralExpression,\n  parserContext: ParserContext,\n): PropMappings {\n  const { sourceFile, checker } = parserContext\n  return convertObjectLiteralToJs(objectLiteral, sourceFile, checker, (valueNode) => {\n    if (ts.isCallExpression(valueNode)) {\n      return parseIntrinsic(valueNode, parserContext)\n    }\n    return expressionToFccEnumValue(valueNode, parserContext)\n  }) as PropMappings\n}\n\nexport type PropMappings = Record<string, Intrinsic>\n"]}