{"version":3,"file":"upload.js","sourceRoot":"","sources":["../../src/connect/upload.ts"],"names":[],"mappings":"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","sourcesContent":["import { CodeConnectJSON } from '../connect/figma_connect'\nimport { logger, underline, highlight } from '../common/logging'\nimport { getApiUrl, getHeaders } from './figma_rest_api'\nimport { exitWithFeedbackMessage } from './helpers'\nimport { parseFigmaNode } from './validation'\nimport { isFetchError, request } from '../common/fetch'\n\ninterface Args {\n  accessToken: string\n  docs: CodeConnectJSON[]\n  batchSize?: number\n  verbose: boolean\n  apiUrl?: string\n}\n\ninterface UploadResponse {\n  status: number\n  error: boolean\n  meta: {\n    success: boolean\n    published_count: number\n    failed_count: number\n    published_nodes: Array<{ figmaNode: string; label: string }>\n    failed_nodes: Array<{ figmaNode: string; label: string; reason: string }>\n  }\n}\n\n/**\n * Returns a string representation of the code connect JSON\n * @param doc - The code connect JSON\n * @returns A string representation of the code connect JSON\n */\nfunction codeConnectStr(doc: CodeConnectJSON): string {\n  return `${highlight(doc.component ?? '')}${doc.variant ? `(${Object.entries(doc.variant).map(([key, value]) => `${key}=${value}`)})` : ''} ${underline(doc.figmaNode)}`\n}\n\n/**\n * Extracts the fileKey and nodeId from the Figma node URL and returns a key in the format of fileKey-nodeId\n * @param figmaNode - The Figma node URL\n * @returns The key in the format of fileKey-nodeId\n */\nfunction getKeyFromFigmaNode(figmaNode: string): string {\n  const url = new URL(figmaNode)\n\n  // Extract fileKey from path (after /file/ or /design/)\n  const pathMatch = url.pathname.match(/\\/(file|design)\\/([A-Za-z0-9]+)/)\n  const fileKey = pathMatch ? pathMatch[2] : ''\n\n  // Extract nodeId from query parameter and convert format (1-24 -> 1:24)\n  const nodeIdParam = url.searchParams.get('node-id') || ''\n  const nodeId = nodeIdParam.replace(/-/g, ':')\n\n  return `${fileKey}-${nodeId}`\n}\n\n/**\n * Creates a map from fileKey-nodeId to original docs for easy lookup\n */\nexport function createDocsMap(\n  docs: CodeConnectJSON[],\n  verbose: boolean,\n): Map<string, CodeConnectJSON[]> {\n  const docsMap = new Map<string, CodeConnectJSON[]>()\n\n  for (const doc of docs) {\n    const parsedData = parseFigmaNode(verbose, doc)\n    if (!parsedData) {\n      continue\n    }\n\n    const mapKey = `${parsedData.fileKey}-${parsedData.nodeId}`\n    if (!docsMap.has(mapKey)) {\n      docsMap.set(mapKey, [])\n    }\n\n    docsMap.get(mapKey)?.push(doc)\n  }\n\n  return docsMap\n}\n\nexport async function upload({\n  accessToken,\n  docs,\n  batchSize,\n  verbose,\n  apiUrl: apiUrlOverride,\n}: Args) {\n  const apiUrl = getApiUrl(docs?.[0]?.figmaNode ?? '', apiUrlOverride) + '/code_connect'\n\n  // Strip internal fields before uploading to Figma\n  const cleanedDocs = docs.map((doc) => {\n    const { _codeConnectFilePath, ...cleanDoc } = doc\n    return cleanDoc as CodeConnectJSON\n  })\n\n  try {\n    logger.info(`Uploading to Figma...`)\n\n    // Create a map from fileKey-nodeId to original docs for detailed output\n    const docsMap = createDocsMap(cleanedDocs, verbose)\n\n    let allUploadedNodes = new Set<string>()\n    let allFailedNodes = new Map<string, string>() // key -> failure reason\n\n    if (batchSize) {\n      if (typeof batchSize !== 'number') {\n        logger.error('Batch size must be a number')\n        exitWithFeedbackMessage(1)\n      }\n\n      // batch together based on fileKey + nodeId as all variants etc of the same node should be uploaded together\n      // Otherwise, the server will overwrite the previous upload\n      const groupedDocs = cleanedDocs.reduce(\n        (acc, doc) => {\n          const parsedData = parseFigmaNode(verbose, doc)\n\n          if (!parsedData) {\n            exitWithFeedbackMessage(1)\n          }\n\n          const { fileKey, nodeId } = parsedData\n          const accKey = fileKey + ',' + nodeId\n          if (!acc[accKey]) {\n            acc[accKey] = []\n          }\n          acc[accKey].push(doc)\n          return acc\n        },\n        {} as Record<string, CodeConnectJSON[]>,\n      )\n\n      const batchedDocs: CodeConnectJSON[][] = []\n      const nodeKeys = Object.keys(groupedDocs)\n\n      for (let i = 0; i < nodeKeys.length; i += batchSize) {\n        const batch: CodeConnectJSON[] = []\n        for (let j = i; j < i + batchSize && j < nodeKeys.length; j++) {\n          const nodeKey = nodeKeys[j]\n          batch.push(...groupedDocs[nodeKey])\n        }\n        batchedDocs.push(batch)\n      }\n\n      let currentBatch = 1\n      const noOfBatches = batchedDocs.length\n      for (const batch of batchedDocs) {\n        process.stderr.write('\\x1b[2K\\x1b[0G')\n        process.stderr.write(`Uploading batch ${currentBatch}/${noOfBatches}`)\n\n        var size = Buffer.byteLength(JSON.stringify(batch)) / (1024 * 1024)\n\n        // Server has a limit of 5mb\n        if (size > 5) {\n          logger.error(\n            `Failed to upload to Figma: The request is too large (${size.toFixed(2)}mb).`,\n          )\n          logger.error(\n            'Please try reducing the size of uploads by splitting them into smaller requests by running again and decreasing the --batch-size parameter.',\n          )\n          exitWithFeedbackMessage(1)\n        }\n\n        logger.debug(`Uploading ${size.toFixed(2)}mb to Figma`)\n\n        const response = await request.post<UploadResponse>(apiUrl, batch, {\n          headers: getHeaders(accessToken),\n        })\n\n        const data = response.data\n\n        if (data.meta?.published_nodes) {\n          data.meta.published_nodes.forEach((node) =>\n            allUploadedNodes.add(getKeyFromFigmaNode(node.figmaNode)),\n          )\n        }\n        if (data.meta?.failed_nodes) {\n          data.meta.failed_nodes.forEach((node) =>\n            allFailedNodes.set(getKeyFromFigmaNode(node.figmaNode), node.reason),\n          )\n        }\n\n        currentBatch++\n      }\n      process.stderr.write(`\\n`)\n    } else {\n      var size = Buffer.byteLength(JSON.stringify(cleanedDocs)) / (1024 * 1024)\n\n      // Server has a limit of 5mb\n      if (size > 5) {\n        logger.error(`Failed to upload to Figma: The request is too large (${size.toFixed(2)}mb).`)\n        logger.error(\n          'Please try reducing the size of uploads by splitting them into smaller requests by running again with the --batch-size parameter. You can do also this by running on different subdirectories using the --dir flag or by iteratively adjusting the includes field in the configuration.',\n        )\n        exitWithFeedbackMessage(1)\n      }\n\n      logger.debug(`Uploading ${size.toFixed(2)}mb to Figma`)\n      logger.info(`uploading to ${apiUrl}`)\n\n      const response = await request.post<UploadResponse>(apiUrl, cleanedDocs, {\n        headers: getHeaders(accessToken),\n      })\n\n      const data = response.data\n\n      if (data.meta?.published_nodes) {\n        data.meta.published_nodes.forEach((node) =>\n          allUploadedNodes.add(getKeyFromFigmaNode(node.figmaNode)),\n        )\n      }\n      if (data.meta?.failed_nodes) {\n        data.meta.failed_nodes.forEach((node) =>\n          allFailedNodes.set(getKeyFromFigmaNode(node.figmaNode), node.reason),\n        )\n      }\n    }\n\n    // Separate successful and failed uploads\n    const successfulDocsByLabel: Record<string, CodeConnectJSON[]> = {}\n    const failedDocsByLabel: Record<string, Array<{ doc: CodeConnectJSON; reason: string }>> = {}\n\n    for (const [mapKey, nodeDocs] of docsMap.entries()) {\n      for (const doc of nodeDocs) {\n        const label = doc.label\n        const docKey = getKeyFromFigmaNode(doc.figmaNode)\n        const isUploaded = allUploadedNodes.has(docKey)\n        const failureReason = allFailedNodes.get(docKey)\n\n        if (isUploaded) {\n          if (!successfulDocsByLabel[label]) {\n            successfulDocsByLabel[label] = []\n          }\n          successfulDocsByLabel[label].push(doc)\n        } else if (failureReason) {\n          if (!failedDocsByLabel[label]) {\n            failedDocsByLabel[label] = []\n          }\n          failedDocsByLabel[label].push({ doc, reason: failureReason })\n        }\n      }\n    }\n\n    for (const [label, docs] of Object.entries(successfulDocsByLabel)) {\n      logger.info(\n        `Successfully uploaded to Figma, for ${label}:\\n${docs.map((doc) => `-> ${codeConnectStr(doc)}`).join('\\n')}`,\n      )\n    }\n\n    if (Object.keys(failedDocsByLabel).length > 0) {\n      for (const [label, failedItems] of Object.entries(failedDocsByLabel)) {\n        logger.error(\n          `Failed to upload to Figma, for ${label}:\\n${failedItems.map((item) => `-> ${codeConnectStr(item.doc)} (${item.reason})`).join('\\n')}`,\n        )\n      }\n    }\n  } catch (err) {\n    if (isFetchError(err)) {\n      if (err.response) {\n        logger.error(\n          `Failed to upload to Figma (${err.response.status}): ${err.response.status} ${err.data?.message}`,\n        )\n      } else {\n        logger.error(`Failed to upload to Figma: ${err.message}`)\n      }\n      logger.debug(JSON.stringify(err?.data))\n    } else {\n      logger.error(`Failed to upload to Figma: ${err}`)\n    }\n    exitWithFeedbackMessage(1)\n  }\n}\n"]}