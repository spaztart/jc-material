{"version":3,"file":"modifiers.js","sourceRoot":"","sources":["../../src/connect/modifiers.ts"],"names":[],"mappings":"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","sourcesContent":["import * as ts from 'typescript'\nimport { ConnectedComponent } from './api'\nimport { ParserContext, ParserError } from './parser_common'\nimport { findJSXElement, parseRenderFunctionExpression } from '../react/parser'\n\nexport enum ModifierKind {\n  GetProps = 'getProps',\n  Render = 'render',\n}\n\nexport interface ModifierBase {\n  kind: ModifierKind\n}\n\nexport interface GetPropsModifier extends ModifierBase {\n  kind: ModifierKind.GetProps\n}\n\nexport interface RenderModifier extends ModifierBase {\n  kind: ModifierKind.Render\n  args: {\n    renderFn: {\n      code: string\n      imports: { statement: string; file: string }[]\n      referencedProps: Set<string>\n    }\n  }\n}\n\nexport type Modifier = GetPropsModifier | RenderModifier\n\ntype PickMatching<T, V> = {\n  [K in keyof T as T[K] extends V ? K : never]: {\n    match: (exp: ts.CallExpression) => exp is ts.CallExpression\n    parse: (exp: ts.CallExpression, parser: ParserContext) => Modifier\n  }\n}\ntype ExtractMethods<T> = PickMatching<T, Function>\n\nconst Modifiers: {\n  [key: string]: {\n    match: (exp: ts.CallExpression) => exp is ts.CallExpression\n    parse: (exp: ts.CallExpression, parser: ParserContext) => Modifier\n  }\n} = {\n  ...getInstanceModifiers(),\n}\n\nfunction makeModifier(\n  modifierName: string,\n  modifier: (exp: ts.CallExpression, parser: ParserContext) => Modifier,\n) {\n  return {\n    match: (exp: ts.CallExpression): exp is ts.CallExpression => {\n      return (\n        ts.isCallExpression(exp) &&\n        ts.isPropertyAccessExpression(exp.expression) &&\n        exp.expression.name.getText() === modifierName\n      )\n    },\n    parse: modifier,\n  }\n}\n\nfunction getInstanceModifiers(): ExtractMethods<ConnectedComponent> {\n  return {\n    getProps: makeModifier('getProps', () => {\n      return {\n        kind: ModifierKind.GetProps,\n      }\n    }),\n    render: makeModifier('render', (exp, parserContext) => {\n      const renderFunction = exp.arguments?.[0]\n      if (\n        renderFunction &&\n        (ts.isArrowFunction(renderFunction) ||\n          ts.isFunctionExpression(renderFunction) ||\n          ts.isFunctionDeclaration(renderFunction)) &&\n        findJSXElement(renderFunction)\n      ) {\n        const { code, imports, referencedProps } = parseRenderFunctionExpression(\n          renderFunction,\n          parserContext,\n        )\n        return {\n          kind: ModifierKind.Render,\n          args: {\n            renderFn: {\n              code,\n              imports,\n              referencedProps,\n            },\n          },\n        }\n      } else {\n        throw new ParserError(\n          'first argument to render() must be a render function that returns a single JSX element',\n          {\n            node: exp,\n            sourceFile: parserContext.sourceFile,\n          },\n        )\n      }\n    }),\n  }\n}\n\nexport function parseModifier(exp: ts.CallExpression, parserContext: ParserContext): Modifier {\n  for (const key in Modifiers) {\n    if (Modifiers[key].match(exp)) {\n      return Modifiers[key].parse(exp, parserContext)\n    }\n  }\n\n  throw new ParserError(`Unknown modifier: ${exp.getText()}`, {\n    node: exp,\n    sourceFile: parserContext.sourceFile,\n  })\n}\n\nexport function modifierToString(modifier: Modifier) {\n  switch (modifier.kind) {\n    case ModifierKind.GetProps: {\n      return '__getProps__()'\n    }\n    case ModifierKind.Render: {\n      const { code, referencedProps } = modifier.args.renderFn\n      return `__renderWithFn__(({${Array.from(referencedProps).join(',')}}) => ${code})`\n    }\n    default:\n      throw new Error('Unknown modifier')\n  }\n}\n"]}