{"version":3,"file":"compiler.js","sourceRoot":"","sources":["../../src/typescript/compiler.ts"],"names":[],"mappings":"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","sourcesContent":["import ts, { isTaggedTemplateExpression } from 'typescript'\nimport { ParserContext, ParserError } from '../connect/parser_common'\n\n/**\n * Get the default export from a TypeScript source file\n *\n * @param sourceFile TypeScript source file\n * @returns The default export Expression, or undefined if there is no default export\n */\nexport function getDefaultExport(sourceFile: ts.SourceFile): ts.Expression | undefined {\n  for (const statement of sourceFile.statements) {\n    if (ts.isExportAssignment(statement) && ts.isIdentifier(statement.expression)) {\n      // The default export is a reference to another variable\n      const identifierName = statement.expression.text\n      // Find the variable declaration that matches the identifier\n      for (const stmt of sourceFile.statements) {\n        if (ts.isVariableStatement(stmt)) {\n          for (const declaration of stmt.declarationList.declarations) {\n            if (ts.isIdentifier(declaration.name) && declaration.name.text === identifierName) {\n              // Return the initializer of the variable declaration\n              return declaration.initializer\n            }\n          }\n        }\n      }\n    } else if (ts.isExportAssignment(statement)) {\n      // The default export is not a reference to another variable\n      return statement.expression\n    }\n  }\n}\n/**\n * Perform a breadth-first search to find the first node matching a predicate\n *\n * @param node Node to start the search from\n * @param tsSourceFile SourceFile associated with the node\n * @param predicate Predicate to match\n * @returns The first node matching the predicate, or undefined if no node is found\n */\nexport function bfsFindNode(\n  node: ts.Node,\n  tsSourceFile: ts.SourceFile,\n  predicate: (node: ts.Node) => boolean,\n): ts.Node | undefined {\n  const queue = [node]\n  while (queue.length > 0) {\n    node = queue.shift()!\n    if (predicate(node)) {\n      return node\n    }\n\n    if (node && node.getChildCount(tsSourceFile) > 0) {\n      queue.push(...node.getChildren(tsSourceFile))\n    }\n  }\n}\n\n/**\n * Gets a property with the specified name and type (via predicate) from an object literal node\n *\n * @param objectLiteralNode The object literal node potentially containing the property\n * @param propertyName The name of the property to get\n * @param predicate Optional predicate to match\n * @param required Whether the property is required. Defaults to false.\n * If true, an error will be thrown if the property is not found\n * @param errorMessage Optional error message to throw if the property is not found\n * @returns The property, or undefined if the property is not found\n */\nexport function parsePropertyOfType<T extends ts.Node>(params: {\n  objectLiteralNode: ts.ObjectLiteralExpression\n  propertyName: string\n  predicate: (node: ts.Node) => node is T\n  parserContext: ParserContext\n  required?: true\n  errorMessage?: string\n}): T\n\nexport function parsePropertyOfType<T extends ts.Node>(params: {\n  objectLiteralNode: ts.ObjectLiteralExpression\n  propertyName: string\n  predicate: (node: ts.Node) => node is T\n  parserContext: ParserContext\n  required?: false\n  errorMessage?: string\n}): T | undefined\n\nexport function parsePropertyOfType<T extends ts.Node>(params: {\n  objectLiteralNode: ts.ObjectLiteralExpression\n  propertyName: string\n  predicate: (node: ts.Node) => node is T\n  parserContext: ParserContext\n  required?: boolean\n  errorMessage?: string\n}): T | undefined\n\nexport function parsePropertyOfType<T extends ts.Node>({\n  objectLiteralNode,\n  propertyName,\n  predicate,\n  parserContext,\n  required = false,\n  errorMessage,\n}: {\n  objectLiteralNode: ts.ObjectLiteralExpression\n  propertyName: string\n  predicate: (node: ts.Node) => node is T\n  parserContext: ParserContext\n  required?: boolean\n  errorMessage?: string\n}): T | undefined {\n  const { sourceFile, checker } = parserContext\n  const node = objectLiteralNode.properties.find(\n    (property) => property.name?.getText() === propertyName,\n  )\n\n  if (!node) {\n    if (!required) {\n      return undefined\n    } else {\n      throw new ParserError(errorMessage ?? `Expected property '${propertyName}' to be present`, {\n        sourceFile,\n        node: objectLiteralNode,\n      })\n    }\n  }\n\n  let initializer: ts.Expression | undefined\n\n  if (ts.isPropertyAssignment(node)) {\n    if (ts.isIdentifier(node.initializer)) {\n      const symbol = checker.getSymbolAtLocation(node.initializer)\n      if (symbol) {\n        const decl = symbol.valueDeclaration\n        if (decl && ts.isVariableDeclaration(decl) && decl.initializer) {\n          initializer = decl.initializer\n        }\n      }\n    } else {\n      initializer = node.initializer\n    }\n  }\n\n  if (ts.isShorthandPropertyAssignment(node)) {\n    const symbol = checker.getShorthandAssignmentValueSymbol(node)\n    if (!symbol || !symbol.valueDeclaration || !ts.isVariableDeclaration(symbol.valueDeclaration)) {\n      throw new ParserError('Expected shorthand property to be declared in the same file', {\n        sourceFile,\n        node,\n      })\n    }\n    initializer = symbol.valueDeclaration.initializer\n  }\n\n  if (!initializer) {\n    throw new ParserError(`Expected property ${propertyName} to be a property assignment`, {\n      sourceFile,\n      node,\n    })\n  }\n\n  // Unwrap `as Type` or `satisfies Type` expressions\n  if (ts.isAsExpression(initializer) || ts.isSatisfiesExpression(initializer)) {\n    initializer = initializer.expression\n  }\n\n  if (!predicate(initializer)) {\n    throw new ParserError(\n      errorMessage ??\n        `Unexpected shape of property ${propertyName}, got node type: ${ts.SyntaxKind[initializer.kind]}`,\n      {\n        sourceFile,\n        node: initializer,\n      },\n    )\n  }\n\n  return initializer\n}\n\ntype TypeGuard<A, B extends A> = (a: A) => a is B\ntype GuardType<T> = T extends (o: any) => o is infer U ? U : never\n\n/**\n * Combines several type guards into one.\n *\n * The returned function checks if any of the type guards in the list matches the argument,\n * and infers the type based on the matching type guard.\n *\n * @param guards A list of type guards\n */\nexport function isOneOf<T extends TypeGuard<any, any>>(\n  guards: T[],\n): [T] extends [TypeGuard<infer A, any>] ? (a: A) => a is GuardType<T> : never\nexport function isOneOf<T extends TypeGuard<any, any>>(guards: T[]) {\n  return function (arg: T) {\n    return guards.some(function (predicate) {\n      return predicate(arg)\n    })\n  }\n}\n\n/**\n * Gets a function argument with the specified index from a call expression node\n *\n * @param fn The call expression node potentially containing the argument\n * @param parserContext The parser context\n * @param index The index of the argument to get\n * @param predicate Predicate to match\n * @param required Whether the argument is required. Defaults to false.\n * @param errorMessage Optional error message to throw if the argument is not found\n * @returns\n */\nexport function parseFunctionArgument<T extends ts.Node>(\n  fn: ts.CallExpression,\n  parserContext: ParserContext,\n  index: number,\n  predicate: (node: ts.Node) => node is T,\n  required = false,\n  errorMessage?: string,\n): T | undefined {\n  const { sourceFile } = parserContext\n\n  if (fn.arguments.length <= index && !required) {\n    return undefined\n  }\n\n  if (fn.arguments.length <= index) {\n    throw new ParserError(\n      errorMessage ?? `Expected function to have at least ${index + 1} arguments`,\n      {\n        sourceFile,\n        node: fn,\n      },\n    )\n  }\n\n  const arg = fn.arguments[index]\n  if (!arg || !predicate(arg)) {\n    throw new ParserError(errorMessage ?? `Unexpected shape of argument ${index}`, {\n      sourceFile,\n      node: fn.arguments[index],\n    })\n  }\n\n  return arg\n}\n\nexport function assertIsPropertyAssignment(\n  node: ts.Node,\n  sourceFile: ts.SourceFile,\n): asserts node is ts.PropertyAssignment {\n  if (!ts.isPropertyAssignment(node)) {\n    throw new ParserError(`Expected a property assignment, got ${ts.SyntaxKind[node.kind]}`, {\n      node,\n      sourceFile,\n    })\n  }\n}\n\nexport function assertIsStringLiteral(\n  node: ts.Node,\n  sourceFile: ts.SourceFile,\n  msg?: string,\n): asserts node is ts.StringLiteral {\n  if (!ts.isStringLiteral(node)) {\n    throw new ParserError(msg ?? `Expected a string literal, got ${ts.SyntaxKind[node.kind]}`, {\n      node,\n      sourceFile,\n    })\n  }\n}\n\nexport function assertIsArrayLiteralExpression(\n  node: ts.Node,\n  sourceFile: ts.SourceFile,\n  msg?: string,\n): asserts node is ts.ArrayLiteralExpression {\n  if (!ts.isArrayLiteralExpression(node)) {\n    throw new ParserError(msg ?? `Expected an array literal, got ${ts.SyntaxKind[node.kind]}`, {\n      node,\n      sourceFile,\n    })\n  }\n}\n\nexport function assertIsObjectLiteralExpression(\n  node: ts.Node,\n  sourceFile: ts.SourceFile,\n  msg?: string,\n): asserts node is ts.ObjectLiteralExpression {\n  if (!ts.isObjectLiteralExpression(node)) {\n    throw new ParserError(msg ?? `Expected an object literal, got ${ts.SyntaxKind[node.kind]}`, {\n      node,\n      sourceFile,\n    })\n  }\n}\n\nexport function assertIsIdentifier(\n  node: ts.Node,\n  sourceFile: ts.SourceFile,\n  msg?: string,\n): asserts node is ts.Identifier {\n  if (!ts.isIdentifier(node)) {\n    throw new ParserError(msg ?? `Expected an identifier, got ${ts.SyntaxKind[node.kind]}`, {\n      node,\n      sourceFile,\n    })\n  }\n}\n\nfunction convertValueNodeToJs(\n  valueNode: ts.Expression,\n  sourceFile: ts.SourceFile,\n  checker: ts.TypeChecker,\n  extraConversionFn?: (node: ts.Expression) => any,\n): any {\n  if (ts.isObjectLiteralExpression(valueNode)) {\n    // A prop mapping to an object literal, which maps each figma value to a code value\n    return convertObjectLiteralToJs(valueNode, sourceFile, checker, extraConversionFn)\n  } else {\n    // A prop mapping to anything else, which will be passed as a literal value\n    if (ts.isStringLiteral(valueNode)) {\n      // Accessing `text` directly prevents the value being wrapped in quotes\n      return valueNode.text\n    } else if (valueNode.kind === ts.SyntaxKind.TrueKeyword) {\n      return true\n    } else if (valueNode.kind === ts.SyntaxKind.FalseKeyword) {\n      return false\n      // undefined is not a keyword in TypeScript, but actually translates to an identifier\n      // (even though confusingly ts.SyntaxKind.UndefinedKeyword exists)\n    } else if (ts.isIdentifier(valueNode) && valueNode.text === 'undefined') {\n      return undefined\n    } else if (valueNode.kind === ts.SyntaxKind.NullKeyword) {\n      return null\n    } else if (valueNode.kind === ts.SyntaxKind.NumericLiteral) {\n      return parseFloat(valueNode.getText())\n    } else if (isTaggedTemplateExpression(valueNode)) {\n      // Return the content of the template string without the backticks\n      return valueNode.template.getText().replace(/^`/, '').replace(/`$/, '')\n    } else {\n      return valueNode.getText()\n    }\n  }\n}\n\n/**\n * Convert an object literal node to a JavaScript object\n *\n * @param objectLiteral The object literal node to convert\n * @param sourceFile The source file containing the object literal\n * @param extraConversionFn Optional function to convert a node to a value. This\n * runs before the default conversion. If this returns undefined, the default\n * conversion will be used. (This does mean there's no way to return undefined)\n * @returns The JavaScript object version of the object literal\n */\nexport function convertObjectLiteralToJs(\n  objectLiteral: ts.ObjectLiteralExpression,\n  sourceFile: ts.SourceFile,\n  checker: ts.TypeChecker,\n  extraConversionFn?: (node: ts.Expression) => any,\n) {\n  const obj = {} as Record<string, any>\n  const properties = [...objectLiteral.properties]\n\n  while (properties.length > 0) {\n    const prop = properties.shift()!\n\n    // If the value is a spread assignment, we need to resolve the object it's spreading\n    // and add its properties to the current object\n    if (ts.isSpreadAssignment(prop)) {\n      const declaration = bfsFindNode(sourceFile, sourceFile, (node) => {\n        return ts.isVariableDeclaration(node) && node.name.getText() === prop.expression.getText()\n      }) as ts.VariableDeclaration\n      if (!declaration.initializer || !ts.isObjectLiteralExpression(declaration.initializer)) {\n        throw new ParserError('Expected spread object to be an object literal', {\n          sourceFile,\n          node: prop,\n        })\n      }\n\n      for (const prop of declaration.initializer.properties) {\n        properties.push(prop)\n      }\n      continue\n    }\n\n    assertIsPropertyAssignment(prop, sourceFile)\n    if (!ts.isIdentifier(prop.name) && !ts.isStringLiteral(prop.name)) {\n      throw new ParserError('Expected property key to be an identifier or String Literal', {\n        sourceFile,\n        node: prop,\n      })\n    }\n    const key = prop.name.text\n    const valueNode = prop.initializer\n\n    const extraConversionResult = extraConversionFn && extraConversionFn(valueNode)\n\n    if (extraConversionResult !== undefined) {\n      obj[key] = extraConversionResult\n    } else {\n      obj[key] = convertValueNodeToJs(valueNode, sourceFile, checker, extraConversionFn)\n    }\n  }\n\n  return obj\n}\n\n/**\n * Convert an Array literal node to a JavaScript array\n *\n * @param arrayLiteral The array literal node to convert\n * @param sourceFile The source file containing the array literal\n * @param extraConversionFn Optional function to convert a node to a value. This\n * runs before the default conversion. If this returns undefined, the default\n * conversion will be used. (This does mean there's no way to return undefined)\n * @returns The JavaScript object version of the object literal\n */\nexport function convertArrayLiteralToJs(\n  arrayLiteral: ts.ArrayLiteralExpression,\n  sourceFile: ts.SourceFile,\n  checker: ts.TypeChecker,\n  extraConversionFn?: (node: ts.Expression) => any,\n) {\n  return arrayLiteral.elements.map((element) => {\n    const extraConversionResult = extraConversionFn && extraConversionFn(element)\n    if (extraConversionResult !== undefined) {\n      return extraConversionResult\n    } else {\n      return convertValueNodeToJs(element, sourceFile, checker, extraConversionFn)\n    }\n  })\n}\n\nexport function getTagName(element: ts.JsxElement | ts.JsxSelfClosingElement) {\n  if (ts.isJsxSelfClosingElement(element)) {\n    return element.tagName.getText()\n  } else {\n    return element.openingElement.tagName.getText()\n  }\n}\n\nexport function stripQuotesFromNode(node: ts.StringLiteral) {\n  return stripQuotes(node.text)\n}\n\nfunction stripQuotes(text: string) {\n  if (text.startsWith('\"') || text.startsWith(\"'\")) {\n    return text.substring(1, text.length - 1)\n  }\n  return text\n}\n\nexport function isUndefinedType(node: ts.Node, checker: ts.TypeChecker): boolean {\n  const type = checker.getTypeAtLocation(node)\n  return (type.getFlags() & ts.TypeFlags.Undefined) !== 0\n}\n"]}