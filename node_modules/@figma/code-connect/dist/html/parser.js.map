{"version":3,"file":"parser.js","sourceRoot":"","sources":["../../src/html/parser.ts"],"names":[],"mappings":"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","sourcesContent":["import ts, { isReturnStatement, isTemplateExpression, SyntaxKind } from 'typescript'\nimport {\n  stripQuotesFromNode,\n  parsePropertyOfType,\n  parseFunctionArgument,\n} from '../typescript/compiler'\nimport { FIGMA_CONNECT_CALL, PropMappings, parsePropsObject } from '../connect/intrinsics'\nimport { CodeConnectJSON } from '../connect/figma_connect'\nimport { getParsedTemplateHelpersString } from './parser_template_helpers'\nimport { JSDOM } from 'jsdom'\nimport { parse } from 'parse5'\nimport {\n  makeCreatePropPlaceholder,\n  ParserContext,\n  visitPropReferencingNode,\n  getReferencedPropsForTemplate,\n  ParserError,\n  parseLinks,\n  parseVariant,\n  parseImports,\n  ParseOptions,\n} from '../connect/parser_common'\nimport { CodeConnectParser, DEFAULT_LABEL_PER_PARSER } from '../connect/project'\nimport { SyntaxHighlightLanguage } from '../connect/label_language_mapping'\nimport { format } from 'prettier'\n\nfunction getHtmlTaggedTemplateNode(node: ts.Node): ts.TaggedTemplateExpression | undefined {\n  if (ts.isTaggedTemplateExpression(node)) {\n    const tag = node.tag\n    if (ts.isIdentifier(tag) && tag.text === 'html') {\n      return node\n    }\n  } else if (\n    ts.isBlock(node) &&\n    node.statements.length === 1 &&\n    ts.isReturnStatement(node.statements[0]) &&\n    node.statements[0].expression &&\n    ts.isTaggedTemplateExpression(node.statements[0].expression) &&\n    ts.isIdentifier(node.statements[0].expression.tag) &&\n    node.statements[0].expression.tag.text === 'html'\n  ) {\n    return node.statements[0].expression\n  }\n\n  return undefined\n}\n\n/**\n * This function converts the HTML template literal into a DOM (using JSDOM) to\n * extract information which is used in generating the template:\n * 1. A dictionary of template placeholders which correspond to HTML attribute\n *    values. The key is the placeholder index, and the value is the attribute\n *    name. The attribute name is unused (it used to be used in the output, but\n *    we need to preserve case to support Angular, which JSDOM can't do unless\n *    you use XHTML mode, and that doesn't support attributes without a value).\n * 2. Whether the template is \"nestable\" or not. A template is considered\n *    nestable if it has only one top level element.\n *\n * For finding the attribute placeholders, the algorithm is as follows:\n * 1. Build up a full string from the template literal, replacing any value\n *    ${placeholders} with `__FIGMA_PLACEHOLDER_0`, where 0 is the placeholder\n *    index. This results in a valid HTML string, with placeholders we can later\n *    detect.\n * 2. Use JSDOM to turn this into a DOM.\n * 3. Iterate over every node in the DOM, and if the node has any attributes\n *    starting `__FIGMA_PLACEHOLDER`, store the info of these attributes. This\n *    allows us to know which template literal placeholders correspond to HTML\n *    attributes when we construct the template.\n */\nfunction getInfoFromDom(\n  templateExp: ts.TemplateExpression | ts.TaggedTemplateExpression,\n  parserContext: ParserContext,\n): {\n  attributePlaceholders: Record<number, string>\n  nestable: boolean\n} {\n  let htmlString: string\n\n  if (ts.isTemplateExpression(templateExp)) {\n    // If this is a template expression, build up the HTML string with\n    // identifiable placeholders as described above\n    htmlString = templateExp.head.text\n    templateExp.templateSpans.forEach((part, index) => {\n      htmlString += `__FIGMA_PLACEHOLDER_${index}` + part.literal.text\n    })\n  } else if (templateExp.template.kind === ts.SyntaxKind.FirstTemplateToken) {\n    // This is just a template literal with no placeholders\n    htmlString = templateExp.template.text\n  } else {\n    // This should never happen as we check the type in the calling function\n    throw new Error(`Unsupported template type: ${SyntaxKind[templateExp.template.kind]}`)\n  }\n\n  // First, check for HTML which we cannot handle. JSDOM is quite forgiving,\n  // like a browser, but we need to be stricter\n  //\n  // Duplicate attribute names are handled gracefully by JSDOM (it just keeps\n  // one of the attributes), but this breaks our algorithm because some of the\n  // placeholders are no longer in the DOM. JSDOM has no way to detect this, but\n  // parse5 (which is a library JSDOM uses under the hood) can detect this. We\n  // just thrown an error in this case as there's no use case for doing this.\n  parse(htmlString, {\n    onParseError: (error) => {\n      if (error.code === 'duplicate-attribute') {\n        throw new ParserError(`Duplicate attribute name in example HTML`, {\n          node: templateExp,\n          sourceFile: parserContext.sourceFile,\n        })\n      }\n    },\n  })\n\n  // Try to format the HTML with prettier, to catch any errors due to invalid\n  // HTML which would otherwise result in broken formatting in the UI as\n  // prettier is less forgiving\n  try {\n    // pluginSearchDirs: false is needed as otherwise prettier picks up other\n    // prettier plugins in our monorepo and fails on CI\n    format(htmlString, { parser: 'html', pluginSearchDirs: false })\n  } catch (e) {\n    throw new ParserError(`Error parsing example HTML. Check the HTML is valid.`, {\n      node: templateExp,\n      sourceFile: parserContext.sourceFile,\n    })\n  }\n\n  // Create a DOM with JSDOM.\n  //\n  // JSDOM doesn't work properly in all cases if we parse a DOM without a full\n  // document, e.g. Vue templates - when traversing with NodeIterator, it\n  // doesn't find all elements. We create a Fragment then append it to a full\n  // DOM to work around this. The extra wrapping elements don't matter, as we're\n  // only interested in the attributes.\n  const fragment = JSDOM.fragment(htmlString)\n  const dom = new JSDOM('<!DOCTYPE html><html><body></body></html>')\n  dom.window.document.body.appendChild(fragment)\n\n  const document = dom.window.document\n  const NodeFilter = dom.window.NodeFilter\n\n  const attributePlaceholders: Record<number, string> = {}\n\n  function iterateNodeIterator(nodeIterator: NodeIterator) {\n    let currentNode: Node | null\n\n    while ((currentNode = nodeIterator.nextNode())) {\n      // I couldn't work out how to do this in a way which satisfies TypeScript,\n      // so using a check and a cast\n      if (currentNode.nodeType === dom.window.Node.ELEMENT_NODE) {\n        // Check for any attributes which correspond to placeholders in the\n        // template literal, and store their index and name\n        for (let attr of (currentNode as Element).attributes) {\n          if (attr.value.startsWith('__FIGMA_PLACEHOLDER_')) {\n            attributePlaceholders[parseInt(attr.value.split('__FIGMA_PLACEHOLDER_')[1])] = attr.name\n          }\n        }\n      }\n\n      // <TEMPLATE> nodes are not iterated over by default, as they are a way to\n      // store a fragment which is not rendered immediately. These are used in\n      // e.g. Vue templates, so we need to  iterate over them explicitly.\n      if (currentNode.nodeName === 'TEMPLATE') {\n        const templateContent = (currentNode as HTMLTemplateElement).content\n        const templateNodeIterator = document.createNodeIterator(\n          templateContent,\n          NodeFilter.SHOW_ELEMENT,\n          null,\n        )\n        iterateNodeIterator(templateNodeIterator)\n      }\n    }\n  }\n\n  // Iterate over all the nodes in the DOM\n  const nodeIterator = document.createNodeIterator(document.body, NodeFilter.SHOW_ELEMENT, null)\n  iterateNodeIterator(nodeIterator)\n\n  // We check if there is more than one top level child, as we use this as a\n  // signal that the template is not \"nestable\" (and so we render an instance\n  // pill rather than render the child's code inline in the UI)\n  const topLevelChildrenCount = document.body.children.length\n\n  return {\n    attributePlaceholders,\n    nestable: topLevelChildrenCount === 1,\n  }\n}\n\nfunction escapeTemplateString(code: string) {\n  return code.replace(/`/g, '\\\\`').replace(/\\$\\{/g, '\\\\${')\n}\n\n/**\n * Parses the example template string passed to `figma.connect()`.\n *\n * @param exp A function or arrow function expression\n * @param parserContext Parser context\n * @param propMappings Prop mappings object as returned by parseProps\n *\n * @returns The code of the render function and a list of imports\n */\nexport function parseExampleTemplate(\n  exp: ts.ArrowFunction,\n  parserContext: ParserContext,\n  propMappings?: PropMappings,\n  skipTemplateHelpers?: boolean,\n) {\n  const { sourceFile } = parserContext\n\n  if (exp.parameters.length > 1) {\n    throw new ParserError(\n      `Expected a single props parameter for the render function, got ${exp.parameters.length} parameters`,\n      { sourceFile, node: exp },\n    )\n  }\n\n  const propsParameter = exp.parameters[0]\n\n  if (!exp.body) {\n    throw new ParserError(`Expected a body for the render function`, { sourceFile, node: exp })\n  }\n\n  // If the body is a string literal, we generate a `figma.value` statement instead, which just\n  // renders the string as-is in code examples\n  if (ts.isStringLiteral(exp.body)) {\n    const printer = ts.createPrinter()\n    if (!exp.body) {\n      throw new ParserError('Expected a function body', {\n        sourceFile: parserContext.sourceFile,\n        node: exp,\n      })\n    }\n    let exampleCode = printer.printNode(ts.EmitHint.Unspecified, exp.body, sourceFile)\n\n    let templateCode = ''\n    if (!skipTemplateHelpers) {\n      templateCode = getParsedTemplateHelpersString() + '\\n\\n'\n    }\n\n    templateCode += `const figma = require('figma')\\n\\n`\n\n    templateCode += getReferencedPropsForTemplate({\n      propMappings,\n      exp,\n      sourceFile,\n    })\n\n    exampleCode = exampleCode.replace(/`/g, '\\\\`')\n\n    // Body is a string literal, so there aren't any placeholders\n    templateCode += `export default figma.value(${exampleCode})\\n`\n\n    return {\n      code: templateCode,\n      nestable: true,\n    }\n  }\n\n  const templateNode = getHtmlTaggedTemplateNode(exp.body)\n\n  if (!templateNode) {\n    throw new ParserError(\n      `Expected only a tagged template literal as the body of the render function`,\n      { sourceFile, node: templateNode },\n    )\n  }\n\n  // Keep track of any props which are referenced in the example so that we can\n  // insert the appropriate `figma.properties` call in the JS template\n  const referencedProps = new Set<string>()\n  let exampleCode = ''\n  let nestable = true\n\n  if (isTemplateExpression(templateNode.template)) {\n    // This is a template expression with placeholders\n\n    const createPropPlaceholder = makeCreatePropPlaceholder({\n      propMappings,\n      referencedProps,\n      sourceFile,\n    })\n\n    // Transform the template to replace any props references with placeholder\n    // function calls, normalising the different types of props references\n    const transformedTemplate = ts.transform(templateNode.template, [\n      (context) => (rootNode) => {\n        function visit(node: ts.Node): ts.Node {\n          if (ts.isTemplateSpan(node)) {\n            const visitResult = visitPropReferencingNode({\n              propsParameter,\n              node: node.expression,\n              createPropPlaceholder,\n              useJsx: false,\n            })\n\n            if (visitResult) {\n              return ts.factory.createTemplateSpan(visitResult, node.literal)\n            }\n          }\n\n          return ts.visitEachChild(node, visit, context)\n        }\n        return ts.visitNode(rootNode, visit) as typeof templateNode.template\n      },\n    ]).transformed[0] as typeof templateNode.template\n\n    // Iterate over the template string spans (i.e. the interleaved strings and\n    // placeholders) to build up our example code.\n    //\n    // Each time we encounter a placeholder (which by this point has been\n    // normalised to a __PROP__ placeholder function call), we check if it\n    // corresponds to a HTML attribute based on our previous DOM analysis (see\n    // getInfoFromDom).\n    //\n    // If it does, we replace it with a call to\n    // `_fcc_renderHtmlAttribute(\"attributeName\", propVariableName), otherwise\n    // we replace it with a call to `_fcc_renderHtmlValue(propVariableName)`.\n    //\n    // We have some additional logic to handle cases where the user accidentally\n    // writes `attribute=\"${props.prop}\"` rather than `attribute=${props.prop}`\n    // (which is what we show in the docs), as it's easy to make this mistake\n    // when copy/pasting.\n\n    // Keep track of whether we're inside an attribute value that is wrapped in quotes,\n    // so that we can strip the trailing quote if we are\n    let insideAttributeWithQuotes = false\n\n    const infoFromDom = getInfoFromDom(transformedTemplate, parserContext)\n    const { attributePlaceholders } = infoFromDom\n    nestable = infoFromDom.nestable\n\n    // Handle a chunk of HTML, i.e. a text section of the template string. If\n    // the next placeholder is an attribute and this chunk ends with a HTML\n    // attribute (i.e. matches a regex like ` text=` or ` text=\"`), we remove the\n    // attribute name so that it's not present in the low level template before the\n    // call to _fcc_renderHtmlAttribute.\n    function handleHtmlChunk(html: string, nextPlaceholderIsAttribute: boolean) {\n      // If we were previously inside an attribute value placeholder with quotes\n      // surrounding it, remove the leading quote. We do it like this rather\n      // than always removing the leading quote to avoid situations where we\n      // mistakenly remove a quote that is part of the actual content.\n      if (insideAttributeWithQuotes) {\n        html = html.replace(/^\"/g, '')\n      }\n\n      // If the next placeholder is an attribute, then match the start of the\n      // attribute (`attribute=`) at the end of this chunk, so that we can\n      // remove it from the example code and store the attribute name\n      const attributeMatches = html.match(/(.*\\s)([^\\s]+)=\"?$/s)\n      if (nextPlaceholderIsAttribute && attributeMatches) {\n        // attributeMatches should always have matched here, but we check it\n        // anyway so we can fail gracefully if not\n\n        // Add the code up to the attribute, not including the ` attribute=`\n        // part, as _fcc_renderHtmlAttribute is responsible for (maybe)\n        // rendering that\n        exampleCode += escapeTemplateString(attributeMatches[1])\n\n        // If we are in this block, we know that we've matched an attribute, so\n        // store whether it ends with a quote\n        insideAttributeWithQuotes = html.endsWith('\"')\n\n        // Return the attribute name so we can use it to construct the attribute\n        // in the output. We do this rather than extract it from the HTML with\n        // JSDOM because we want to preserve case, but do not want to parse the\n        // doc as XHTML, so there's no way to do it otherwise.\n        return attributeMatches[2]\n      } else {\n        // No attribute to remove, just add the code\n        exampleCode += escapeTemplateString(html)\n        insideAttributeWithQuotes = false\n      }\n    }\n\n    // Process the first chunk, which is a special case as it is not in templateSpans\n    let maybeAttributeName = handleHtmlChunk(\n      transformedTemplate.head.text,\n      attributePlaceholders[0] !== undefined,\n    )\n\n    // For each section of the template string, check that the expression is a\n    // prop placeholder, then add the appropriate template function call\n    transformedTemplate.templateSpans.forEach((part, index) => {\n      if (!ts.isCallExpression(part.expression)) {\n        throw new ParserError(\n          `Expected a call expression as a placeholder in the template, got ${SyntaxKind[part.expression.kind]}`,\n          { sourceFile, node: part.expression },\n        )\n      }\n\n      const propNameArg = part.expression.arguments[0]\n      if (!ts.isStringLiteral(propNameArg)) {\n        throw new ParserError(\n          `Expected a string literal as the argument to the placeholder call, got ${SyntaxKind[propNameArg.kind]}`,\n          { sourceFile, node: propNameArg },\n        )\n      }\n\n      const propVariableName = propNameArg.text\n\n      if (attributePlaceholders[index]) {\n        exampleCode += `\\${_fcc_renderHtmlAttribute('${maybeAttributeName}', ${propVariableName})}`\n      } else {\n        exampleCode += `\\${_fcc_renderHtmlValue(${propVariableName})}`\n      }\n\n      // Process the next chunk\n      maybeAttributeName = handleHtmlChunk(\n        part.literal.text,\n        attributePlaceholders[index + 1] !== undefined,\n      )\n    })\n  } else if (templateNode.template.kind === ts.SyntaxKind.FirstTemplateToken) {\n    // Template string with no placeholders\n    nestable = getInfoFromDom(templateNode, parserContext).nestable\n    exampleCode = escapeTemplateString(templateNode.template.text)\n  } else {\n    throw new ParserError(\n      `Expected a template expression as the body of the render function, got ${SyntaxKind[(templateNode.template as any).kind]}`,\n      { sourceFile, node: templateNode.template },\n    )\n  }\n\n  let templateCode = ''\n  if (!skipTemplateHelpers) {\n    templateCode = getParsedTemplateHelpersString() + '\\n\\n'\n  }\n\n  templateCode += `const figma = require('figma')\\n\\n`\n\n  templateCode += getReferencedPropsForTemplate({\n    propMappings,\n    exp,\n    sourceFile,\n  })\n\n  templateCode += `export default figma.html\\`${exampleCode}\\`\\n`\n\n  return {\n    code: templateCode,\n    nestable,\n  }\n}\n\nfunction parseFigmaConnectArgs(node: ts.CallExpression, parserContext: ParserContext) {\n  const required = true\n\n  const figmaNodeUrlArg = parseFunctionArgument(\n    node,\n    parserContext,\n    0,\n    ts.isStringLiteral,\n    required,\n    `\\`${FIGMA_CONNECT_CALL}\\` must be called with a Figma Component URL as the first argument. Example usage:\n\\`${FIGMA_CONNECT_CALL}('https://www.figma.com/file/123?node-id=1-1', {\n  example: () => html\\`<button />\\`\n})\\``,\n  )!\n\n  const configObjArg = parseFunctionArgument(\n    node,\n    parserContext,\n    1,\n    ts.isObjectLiteralExpression,\n    true,\n    `The second argument to ${FIGMA_CONNECT_CALL}() must be an object literal. Example usage:\n\\`${FIGMA_CONNECT_CALL}('https://www.figma.com/file/123?node-id=1-1', {\n  example: () => html\\`<button />\\`\n})\\``,\n  )\n\n  return {\n    figmaNodeUrlArg,\n    configObjArg,\n  }\n}\n\nfunction parseConfigObjectArg(\n  configArg: ts.ObjectLiteralExpression | undefined,\n  parserContext: ParserContext,\n) {\n  if (!configArg) {\n    return {\n      propsArg: undefined,\n      exampleArg: undefined,\n      variantArg: undefined,\n      importsArg: undefined,\n      linksArg: undefined,\n    }\n  }\n\n  const propsArg = parsePropertyOfType({\n    objectLiteralNode: configArg,\n    propertyName: 'props',\n    predicate: ts.isObjectLiteralExpression,\n    parserContext,\n    required: false,\n    errorMessage: `The 'props' property must be an object literal. Example usage:\n\\`${FIGMA_CONNECT_CALL}('https://www.figma.com/file/123?node-id=1-1', {\n  props: {\n    disabled: figma.boolean('Disabled'),\n    text: figma.string('TextContent'),\n  },\n  example: (props) => html\\`<my-button disabled=\\${props.disabled} label=\\${props.text} />\\`\n})\\``,\n  })\n\n  const exampleArg = parsePropertyOfType({\n    objectLiteralNode: configArg,\n    propertyName: 'example',\n    predicate: ts.isArrowFunction,\n    parserContext,\n    required: true,\n    errorMessage: `The 'example' property must be an arrow function which returns a html tagged template string. Example usage:\n\\`${FIGMA_CONNECT_CALL}('https://www.figma.com/file/123?node-id=1-1', {\n  example: (props) => html\\`<my-button />\\`\n})\\``,\n  })\n\n  const variantArg = parsePropertyOfType({\n    objectLiteralNode: configArg,\n    propertyName: 'variant',\n    predicate: ts.isObjectLiteralExpression,\n    parserContext,\n    required: false,\n    errorMessage: `The 'variant' property must be an object literal. Example usage:\n\\`${FIGMA_CONNECT_CALL}('https://www.figma.com/file/123?node-id=1-1', {\n  variant: {\n    \"Has Icon\": true\n  },\n  example: (props) => html\\`<my-button />\\`\n})\\``,\n  })\n\n  const linksArg = parsePropertyOfType({\n    objectLiteralNode: configArg,\n    propertyName: 'links',\n    predicate: ts.isArrayLiteralExpression,\n    parserContext,\n    required: false,\n    errorMessage: `The 'links' property must be an array literal. Example usage:\n\\`${FIGMA_CONNECT_CALL}('https://www.figma.com/file/123?node-id=1-1', {\n  links: [\n    { name: 'Storybook', url: 'https://storybook.com' }\n  ],\n  example: (props) => html\\`<my-button />\\`\n})\\``,\n  })\n\n  const importsArg = parsePropertyOfType({\n    objectLiteralNode: configArg,\n    propertyName: 'imports',\n    predicate: ts.isArrayLiteralExpression,\n    parserContext,\n    required: false,\n    errorMessage: `The 'imports' property must be an array literal. Example usage:\n\\`${FIGMA_CONNECT_CALL}('https://www.figma.com/file/123?node-id=1-1', {\n  imports: ['import { Button } from \"./Button\"']\n  example: (props) => html\\`<my-button />\\`,\n})\\``,\n  })\n\n  return {\n    propsArg,\n    exampleArg,\n    variantArg,\n    linksArg,\n    importsArg,\n  }\n}\n\nexport async function parseHtmlDoc(\n  node: ts.CallExpression,\n  parserContext: ParserContext,\n  { skipTemplateHelpers }: ParseOptions,\n): Promise<CodeConnectJSON> {\n  const { checker, sourceFile, config } = parserContext\n\n  // Parse the arguments to the `figma.connect()` call\n  const { figmaNodeUrlArg, configObjArg } = parseFigmaConnectArgs(node, parserContext)\n\n  const { propsArg, exampleArg, variantArg, linksArg, importsArg } = parseConfigObjectArg(\n    configObjArg,\n    parserContext,\n  )\n\n  let figmaNode = stripQuotesFromNode(figmaNodeUrlArg)\n  // TODO This logic is duplicated in connect.ts transformDocFromParser due to some type issues\n  if (config.documentUrlSubstitutions) {\n    Object.entries(config.documentUrlSubstitutions).forEach(([from, to]) => {\n      // @ts-expect-error\n      figmaNode = figmaNode.replace(from, to)\n    })\n  }\n\n  const metadata: any = undefined\n\n  const props = propsArg ? parsePropsObject(propsArg, parserContext) : undefined\n  const render = exampleArg\n    ? parseExampleTemplate(exampleArg, parserContext, props, skipTemplateHelpers)\n    : undefined\n  const variant = variantArg ? parseVariant(variantArg, sourceFile, checker) : undefined\n  const links = linksArg ? parseLinks(linksArg, parserContext) : undefined\n\n  let imports = importsArg ? parseImports(importsArg, parserContext) : undefined\n\n  let template\n  if (render?.code) {\n    template = render.code\n  } else {\n    throw new ParserError(`${FIGMA_CONNECT_CALL}() requires an example function`, {\n      sourceFile,\n      node,\n    })\n  }\n\n  return {\n    figmaNode,\n    label: DEFAULT_LABEL_PER_PARSER.html!,\n    language: SyntaxHighlightLanguage.HTML,\n    component: metadata?.component,\n    source: '',\n    sourceLocation: { line: -1 },\n    variant,\n    template,\n    templateData: {\n      // TODO: `props` here is currently only used for validation purposes,\n      // we should eventually remove it from the JSON payload\n      props,\n      imports,\n      // If there's no render function, the default example is always nestable\n      nestable: render ? render.nestable : true,\n    },\n    links,\n    metadata: {\n      cliVersion: require('../../package.json').version,\n    },\n  }\n}\n"]}